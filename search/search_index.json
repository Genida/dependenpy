{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dependenpy \u00a4 Show the inter-dependencies between modules of Python packages. dependenpy allows you to build a dependency matrix for a set of Python packages. To do this, it reads and searches the source code for import statements. Requirements \u00a4 Dependenpy requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.8 # make it available globally pyenv global system 3 .6.8 Installation \u00a4 With pip : python3.6 -m pip install dependenpy With pipx : python3.6 -m pip install --user pipx pipx install --python python3.6 dependenpy Usage (as a library) \u00a4 from dependenpy import DSM # create DSM dsm = DSM ( 'django' ) # transform as matrix matrix = dsm . as_matrix ( depth = 2 ) # initialize with many packages dsm = DSM ( 'django' , 'meerkat' , 'appsettings' , 'dependenpy' , 'archan' ) with open ( 'output' , 'w' ) as output : dsm . print ( format = 'json' , indent = 2 , output = output ) # access packages and modules meerkat = dsm [ 'meerkat' ] # or dsm.get('meerkat') finder = dsm [ 'dependenpy.finder' ] # or even dsm['dependenpy']['finder'] # instances of DSM and Package all have print, as_matrix, etc. methods meerkat . print_matrix ( depth = 2 ) This package was originally design to work in a Django project. The Django package django-meerkat uses it to display the matrices with Highcharts. Usage (command-line) \u00a4 usage: gen-readme-data.py [-d DEPTH] [-f {csv,json,text}] [-g] [-G] [-h] [-i INDENT] [-l] [-m] [-o OUTPUT] [-t] [-v] PACKAGES [PACKAGES ...] Command line tool for dependenpy Python package. positional arguments: PACKAGES The package list. Can be a comma-separated list. Each package must be either a valid path or a package in PYTHONPATH. optional arguments: -d DEPTH, --depth DEPTH Specify matrix or graph depth. Default: best guess. -f {csv,json,text}, --format {csv,json,text} Output format. Default: text. -g, --show-graph Show the graph (no text format). Default: false. -G, --greedy Explore subdirectories even if they do not contain an __init__.py file. Can make execution slower. Default: false. -h, --help Show this help message and exit. -i INDENT, --indent INDENT Specify output indentation. CSV will never be indented. Text will always have new-lines. JSON can be minified with a negative value. Default: best guess. -l, --show-dependencies-list Show the dependencies list. Default: false. -m, --show-matrix Show the matrix. Default: true unless -g, -l or -t. -o OUTPUT, --output OUTPUT Output to given file. Default: stdout. -t, --show-treemap Show the treemap (work in progress). Default: false. -v, --version Show the current version of the program and exit. Example: $ # running dependenpy on itself $ dependenpy dependenpy -z = Module \u2502 Id \u25020\u25021\u25022\u25023\u25024\u25025\u25026\u25027\u25028\u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u2524 dependenpy.__init__ \u2502 0 \u2502 \u2502 \u2502 \u25024\u2502 \u2502 \u2502 \u2502 \u25022\u2502 dependenpy.__main__ \u2502 1 \u2502 \u2502 \u25021\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 dependenpy.cli \u2502 2 \u25021\u2502 \u2502 \u25021\u2502 \u25024\u2502 \u2502 \u2502 \u2502 dependenpy.dsm \u2502 3 \u2502 \u2502 \u2502 \u2502 \u25022\u25021\u25023\u2502 \u2502 \u2502 dependenpy.finder \u2502 4 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 dependenpy.helpers \u2502 5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 dependenpy.node \u2502 6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u25023\u2502 dependenpy.plugins \u2502 7 \u2502 \u2502 \u2502 \u25021\u2502 \u25021\u2502 \u2502 \u2502 \u2502 dependenpy.structures \u2502 8 \u2502 \u2502 \u2502 \u2502 \u2502 \u25021\u2502 \u2502 \u2502 \u2502","title":"Overview"},{"location":"#dependenpy","text":"Show the inter-dependencies between modules of Python packages. dependenpy allows you to build a dependency matrix for a set of Python packages. To do this, it reads and searches the source code for import statements.","title":"Dependenpy"},{"location":"#requirements","text":"Dependenpy requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.8 # make it available globally pyenv global system 3 .6.8","title":"Requirements"},{"location":"#installation","text":"With pip : python3.6 -m pip install dependenpy With pipx : python3.6 -m pip install --user pipx pipx install --python python3.6 dependenpy","title":"Installation"},{"location":"#usage-as-a-library","text":"from dependenpy import DSM # create DSM dsm = DSM ( 'django' ) # transform as matrix matrix = dsm . as_matrix ( depth = 2 ) # initialize with many packages dsm = DSM ( 'django' , 'meerkat' , 'appsettings' , 'dependenpy' , 'archan' ) with open ( 'output' , 'w' ) as output : dsm . print ( format = 'json' , indent = 2 , output = output ) # access packages and modules meerkat = dsm [ 'meerkat' ] # or dsm.get('meerkat') finder = dsm [ 'dependenpy.finder' ] # or even dsm['dependenpy']['finder'] # instances of DSM and Package all have print, as_matrix, etc. methods meerkat . print_matrix ( depth = 2 ) This package was originally design to work in a Django project. The Django package django-meerkat uses it to display the matrices with Highcharts.","title":"Usage (as a library)"},{"location":"#usage-command-line","text":"usage: gen-readme-data.py [-d DEPTH] [-f {csv,json,text}] [-g] [-G] [-h] [-i INDENT] [-l] [-m] [-o OUTPUT] [-t] [-v] PACKAGES [PACKAGES ...] Command line tool for dependenpy Python package. positional arguments: PACKAGES The package list. Can be a comma-separated list. Each package must be either a valid path or a package in PYTHONPATH. optional arguments: -d DEPTH, --depth DEPTH Specify matrix or graph depth. Default: best guess. -f {csv,json,text}, --format {csv,json,text} Output format. Default: text. -g, --show-graph Show the graph (no text format). Default: false. -G, --greedy Explore subdirectories even if they do not contain an __init__.py file. Can make execution slower. Default: false. -h, --help Show this help message and exit. -i INDENT, --indent INDENT Specify output indentation. CSV will never be indented. Text will always have new-lines. JSON can be minified with a negative value. Default: best guess. -l, --show-dependencies-list Show the dependencies list. Default: false. -m, --show-matrix Show the matrix. Default: true unless -g, -l or -t. -o OUTPUT, --output OUTPUT Output to given file. Default: stdout. -t, --show-treemap Show the treemap (work in progress). Default: false. -v, --version Show the current version of the program and exit. Example: $ # running dependenpy on itself $ dependenpy dependenpy -z = Module \u2502 Id \u25020\u25021\u25022\u25023\u25024\u25025\u25026\u25027\u25028\u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u2524 dependenpy.__init__ \u2502 0 \u2502 \u2502 \u2502 \u25024\u2502 \u2502 \u2502 \u2502 \u25022\u2502 dependenpy.__main__ \u2502 1 \u2502 \u2502 \u25021\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 dependenpy.cli \u2502 2 \u25021\u2502 \u2502 \u25021\u2502 \u25024\u2502 \u2502 \u2502 \u2502 dependenpy.dsm \u2502 3 \u2502 \u2502 \u2502 \u2502 \u25022\u25021\u25023\u2502 \u2502 \u2502 dependenpy.finder \u2502 4 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 dependenpy.helpers \u2502 5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 dependenpy.node \u2502 6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u25023\u2502 dependenpy.plugins \u2502 7 \u2502 \u2502 \u2502 \u25021\u2502 \u25021\u2502 \u2502 \u2502 \u2502 dependenpy.structures \u2502 8 \u2502 \u2502 \u2502 \u2502 \u2502 \u25021\u2502 \u2502 \u2502 \u2502","title":"Usage (command-line)"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . v3.3.0 - 2020-09-04 \u00a4 Compare with v3.2.0 Code Refactoring \u00a4 Poetrize the project ( 811c3fb by Timoth\u00e9e Mazzucotelli). Features \u00a4 Add 'zero' argument to change character for 0 ( 1c13c00 by Timoth\u00e9e Mazzucotelli). Update archan provider for archan 3.0 ( 9249dc1 by Timoth\u00e9e Mazzucotelli). v3.2.0 - 2017-06-27 \u00a4 Compare with v3.1.0 Features \u00a4 Add graph option ( 1ebc8f6 ). Implement archan provider ( 66edb5b ). v3.1.0 - 2017-06-02 \u00a4 Compare with v3.0.0 Features \u00a4 Add -i, --indent option to specify indentation level. Changes \u00a4 Change -i, --enforce-init option to its contrary -g, --greedy . Options -l , -m and -t are now mutually exclusive. Bug fixes \u00a4 Fix imports order ( 9a9fcc3 ). Fix matrix build for depth=0 ( 955cc21 ). Misc \u00a4 Improve cli tool and print methods, v3.0.0 - 2017-05-22 \u00a4 Compare with v2.0.3 This version is a big refactoring. The code is way more object oriented, cleaner, shorter, simpler, smarter, more user friendly- in short: better. Additional features: command line entry point, runtime static imports are now caught (in functions or classes), as well as import statements (previously only from import). v2.0.3 - 2017-04-20 \u00a4 Compare with v2.0.2 Changes \u00a4 Change license from MPL 2.0 to ISC ( 35400bf ). Bug fixes \u00a4 Fix occasional UnicodeEncode when reading utf8 file ( 333e987 ). Handle bad characters in files when parsing with ast ( 200e014 ). v2.0.2 - 2016-10-06 \u00a4 Compare with v1.0.4 Split code in two projects: dependenpy and archan. Update to use Python 3. Various bug fixes, additions, improvements and refactor. v1.0.4 - 2015-03-05 \u00a4 Compare with v1.0.3 Documentation and tests improvements. v1.0.3 - 2015-02-26 \u00a4 Compare with v1.0.2 Bug fixes \u00a4 Add check for target_index not None ( d3e573f ). v1.0.2 - 2015-02-24 \u00a4 Compare with v1.0.1 Features \u00a4 Added CSV export ( ce8a911 ). Bug fixes \u00a4 Fix get_matrix if str instead of int, fix csv write row (extend return None) ( bb1289d ). v1.0.1 - 2015-02-23 \u00a4 Compare with v1.0 Bug fixes \u00a4 Fix hashable for dict ( 7d221db ). Fix path resolver ( 4e8a192 ). v1.0 - 2015-02-23 \u00a4 Compare with v0.2-beta Code refactoring \u00a4 4bd14d9 15ba1e5 12fa604 v0.2-beta - 2015-02-20 \u00a4 Compare with first commit First release.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#v330-2020-09-04","text":"Compare with v3.2.0","title":"v3.3.0 - 2020-09-04"},{"location":"changelog/#code-refactoring","text":"Poetrize the project ( 811c3fb by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#features","text":"Add 'zero' argument to change character for 0 ( 1c13c00 by Timoth\u00e9e Mazzucotelli). Update archan provider for archan 3.0 ( 9249dc1 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#v320-2017-06-27","text":"Compare with v3.1.0","title":"v3.2.0 - 2017-06-27"},{"location":"changelog/#features_1","text":"Add graph option ( 1ebc8f6 ). Implement archan provider ( 66edb5b ).","title":"Features"},{"location":"changelog/#v310-2017-06-02","text":"Compare with v3.0.0","title":"v3.1.0 - 2017-06-02"},{"location":"changelog/#features_2","text":"Add -i, --indent option to specify indentation level.","title":"Features"},{"location":"changelog/#changes","text":"Change -i, --enforce-init option to its contrary -g, --greedy . Options -l , -m and -t are now mutually exclusive.","title":"Changes"},{"location":"changelog/#bug-fixes","text":"Fix imports order ( 9a9fcc3 ). Fix matrix build for depth=0 ( 955cc21 ).","title":"Bug fixes"},{"location":"changelog/#misc","text":"Improve cli tool and print methods,","title":"Misc"},{"location":"changelog/#v300-2017-05-22","text":"Compare with v2.0.3 This version is a big refactoring. The code is way more object oriented, cleaner, shorter, simpler, smarter, more user friendly- in short: better. Additional features: command line entry point, runtime static imports are now caught (in functions or classes), as well as import statements (previously only from import).","title":"v3.0.0 - 2017-05-22"},{"location":"changelog/#v203-2017-04-20","text":"Compare with v2.0.2","title":"v2.0.3 - 2017-04-20"},{"location":"changelog/#changes_1","text":"Change license from MPL 2.0 to ISC ( 35400bf ).","title":"Changes"},{"location":"changelog/#bug-fixes_1","text":"Fix occasional UnicodeEncode when reading utf8 file ( 333e987 ). Handle bad characters in files when parsing with ast ( 200e014 ).","title":"Bug fixes"},{"location":"changelog/#v202-2016-10-06","text":"Compare with v1.0.4 Split code in two projects: dependenpy and archan. Update to use Python 3. Various bug fixes, additions, improvements and refactor.","title":"v2.0.2 - 2016-10-06"},{"location":"changelog/#v104-2015-03-05","text":"Compare with v1.0.3 Documentation and tests improvements.","title":"v1.0.4 - 2015-03-05"},{"location":"changelog/#v103-2015-02-26","text":"Compare with v1.0.2","title":"v1.0.3 - 2015-02-26"},{"location":"changelog/#bug-fixes_2","text":"Add check for target_index not None ( d3e573f ).","title":"Bug fixes"},{"location":"changelog/#v102-2015-02-24","text":"Compare with v1.0.1","title":"v1.0.2 - 2015-02-24"},{"location":"changelog/#features_3","text":"Added CSV export ( ce8a911 ).","title":"Features"},{"location":"changelog/#bug-fixes_3","text":"Fix get_matrix if str instead of int, fix csv write row (extend return None) ( bb1289d ).","title":"Bug fixes"},{"location":"changelog/#v101-2015-02-23","text":"Compare with v1.0","title":"v1.0.1 - 2015-02-23"},{"location":"changelog/#bug-fixes_4","text":"Fix hashable for dict ( 7d221db ). Fix path resolver ( 4e8a192 ).","title":"Bug fixes"},{"location":"changelog/#v10-2015-02-23","text":"Compare with v0.2-beta","title":"v1.0 - 2015-02-23"},{"location":"changelog/#code-refactoring_1","text":"4bd14d9 15ba1e5 12fa604","title":"Code refactoring"},{"location":"changelog/#v02-beta-2015-02-20","text":"Compare with first commit First release.","title":"v0.2-beta - 2015-02-20"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd dependenpy make setup That's it! You now have the dependencies installed. You can run the application with poetry run dependenpy [ARGS...] . Run make help to see all the available actions! Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd dependenpy make setup That's it! You now have the dependencies installed. You can run the application with poetry run dependenpy [ARGS...] . Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"Credits \u00a4 These projects were used to build dependenpy . Thank you! python | poetry | copier-poetry Direct dependencies \u00a4 autoflake | black | colorama | coverage | coverage | failprint | flake8-black | flake8-builtins | flake8-pytest-style | flake8-tidy-imports | flake8-variables-names | flakehell | git-changelog | httpx | invoke | invoke | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | mkdocstrings | mypy | mypy | pytest | pytest | pytest-randomly | pytest-randomly | pytest-sugar | pytest-sugar | pytest-xdist | pytest-xdist | toml | wemake-python-styleguide | wrapt Indirect dependencies \u00a4 ansimarkup | apipkg | appdirs | appnope | astor | astroid | atomicwrites | attrs | backcall | bandit | beautifulsoup4 | certifi | chardet | click | contextvars | darglint | dataclasses | decorator | docutils | entrypoints | eradicate | execnet | flake8 | flake8-bandit | flake8-broken-line | flake8-bugbear | flake8-commas | flake8-comprehensions | flake8-debugger | flake8-docstrings | flake8-eradicate | flake8-isort | flake8-plugin-utils | flake8-polyfill | flake8-quotes | flake8-rst-docstrings | flake8-string-format | future | gitdb | GitPython | h11 | h2 | hpack | hstspreload | httpcore | hyperframe | idna | immutables | importlib-metadata | ipython-genutils | jedi | Jinja2 | joblib | lazy-object-proxy | livereload | lunr | Markdown | MarkupSafe | mccabe | mkdocs-material-extensions | more-itertools | mypy-extensions | nltk | packaging | parso | pathspec | pbr | pep8-naming | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | Pygments | pylint | pymdown-extensions | pyparsing | pytest-forked | pytkdocs | PyYAML | regex | restructuredtext-lint | rfc3986 | six | smmap | sniffio | snowballstemmer | soupsieve | stevedore | termcolor | testfixtures | tornado | tqdm | traitlets | typed-ast | typing-extensions | urllib3 | wcwidth | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build dependenpy . Thank you! python | poetry | copier-poetry","title":"Credits"},{"location":"credits/#direct-dependencies","text":"autoflake | black | colorama | coverage | coverage | failprint | flake8-black | flake8-builtins | flake8-pytest-style | flake8-tidy-imports | flake8-variables-names | flakehell | git-changelog | httpx | invoke | invoke | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | mkdocstrings | mypy | mypy | pytest | pytest | pytest-randomly | pytest-randomly | pytest-sugar | pytest-sugar | pytest-xdist | pytest-xdist | toml | wemake-python-styleguide | wrapt","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"ansimarkup | apipkg | appdirs | appnope | astor | astroid | atomicwrites | attrs | backcall | bandit | beautifulsoup4 | certifi | chardet | click | contextvars | darglint | dataclasses | decorator | docutils | entrypoints | eradicate | execnet | flake8 | flake8-bandit | flake8-broken-line | flake8-bugbear | flake8-commas | flake8-comprehensions | flake8-debugger | flake8-docstrings | flake8-eradicate | flake8-isort | flake8-plugin-utils | flake8-polyfill | flake8-quotes | flake8-rst-docstrings | flake8-string-format | future | gitdb | GitPython | h11 | h2 | hpack | hstspreload | httpcore | hyperframe | idna | immutables | importlib-metadata | ipython-genutils | jedi | Jinja2 | joblib | lazy-object-proxy | livereload | lunr | Markdown | MarkupSafe | mccabe | mkdocs-material-extensions | more-itertools | mypy-extensions | nltk | packaging | parso | pathspec | pbr | pep8-naming | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | Pygments | pylint | pymdown-extensions | pyparsing | pytest-forked | pytkdocs | PyYAML | regex | restructuredtext-lint | rfc3986 | six | smmap | sniffio | snowballstemmer | soupsieve | stevedore | termcolor | testfixtures | tornado | tqdm | traitlets | typed-ast | typing-extensions | urllib3 | wcwidth | zipp More credits from the author","title":"Indirect dependencies"},{"location":"usage/","text":"Usage \u00a4 Importing classes \u00a4 You can directly import the following classes from dependenpy : DSM , Package , Module , Dependency , Matrix and TreeMap . If you need to import other classes, please take a look at the structure of the code. Example: from dependenpy import DSM , Matrix Creation of objects \u00a4 For basic usage, you only have to instantiate a DSM object, and sometimes Matrix and TreeMap . But if you need to do more complicated stuff, you might also want to build instances of Package , Module or Dependency . Create a DSM \u00a4 To create a DSM object, just pass it a list of packages that can be either found on the disk (absolute or relative paths), or in the Python path (like in sys.path ). from dependenpy import DSM django = DSM ( 'django' ) flask = DSM ( 'flask' ) both = DSM ( 'django' , 'flask' ) Three keyword arguments can be given to DSM : build_tree : Boolean build_dependencies : Boolean enforce_init : Boolean The three of them defaults to true. Turning build_tree to false will delay the build of the Python package tree (the exploration of files on the file system). You can later call dsm.build_tree() to build the tree. Turning build_dependencies to false will delay the build of the dependencies (the parsing of the source code to determine the inter-dependencies). You can later call dsm.build_dependencies() to build the dependencies. Note that you won't be able to build the dependencies before the tree has been built. Using true for both build_tree and build_dependencies is recommended since it is done pretty quickly, even for big projects like Django. Turning enforce_init to false will make the exploration of sub-directories complete: by default, a sub-directory is not explored if it does not contain an __init__.py file. It makes the building of the tree faster. But in some cases, you might want to still explore the sub-directory even without __init__.py . In that case, use enforce_init=False . Note that depending on the tree, the build might take longer. Create a Package \u00a4 To create a Package object, initialize it with a name and a path. These two arguments are the only one required. Name should be the name of the Python package (the name of the directory), and path should be the path to the directory on the file system. Example: from dependenpy import Package absolute_package = Package ( 'django' , '/my/virtualenv/lib/python3.5/site-packages/django' ) relative_package = Package ( 'program' , 'src/program' ) Additionally, you can pass 6 more keyword arguments: the same three from DSM ( build_tree , build_dependencies and enforce_init ), and the three following: dsm : parent DSM (instance of DSM). package : parent package (instance of Package). limit_to : list of strings to limit the exploration to a subset of directories. These three arguments default to None . Both dsm and package arguments are useful to build a tree. Argument limit_to can be used this way: from dependenpy import Package django_auth = Package ( 'django' , 'path/to/django' , limit_to = [ 'contrib.auth' ]) Of course, you could also have build a the django_auth Package by directly specify the name and path of the sub-directory, but using limit_to allows you to build the full tree, starting at the root (Django's directory). from dependenpy import Package django_auth = Package ( 'auth' , 'path/to/django/contrib/auth' ) Create a Module \u00a4 To create a Module object, initialize it with a name and a path. These two arguments are the only one required. Name should be the name of the Python module (the file without the .py extension), and path should be the path to the file on the file system. As for Package , dsm and package arguments can be passed when creating a module. Example: from dependenpy import Module dsm_module = Module ( 'dsm' , 'path/to/dependenpy/dsm.py' ) Create a Dependency \u00a4 A dependency is a simple object that require: source : the Module instance importing the item, lineno : the line number at which the import occurred, target : the Package or Module instance from which the item is imported and an optional what argument which defaults to None: the name of the imported item. Create a Matrix \u00a4 From an instance of DSM or Package called node : matrix = node . as_matrix ( depth = 2 ) From a list of nodes (DSMs, packages or modules): matrix = Matrix ( * node_list , depth = 2 ) An instance of Matrix has a data attribute, which is a two-dimensions array of integers, and a keys attribute which is the list of names, in the same order as rows in data. Create a TreeMap \u00a4 From an instance of DSM or Package called node : treemap = node . as_treemap ( depth = 2 ) From a list of nodes (DSMs, packages or modules): matrix = TreeMap ( * node_list , depth = 2 ) An instance of TreeMap has a data attribute, which is a two-dimensions array of integers or treemaps, a keys attribute which is the list of names in the same order as rows in data, and a value attribute which is the total number of dependencies in the treemap. Create a Graph \u00a4 From an instance of DSM or Package called node : graph = node . as_graph ( depth = 2 ) From a list of nodes (DSMs, packages or modules): graph = Graph ( * node_list , depth = 2 ) An instance of Graph has a vertices attribute, which is a list of Vertex instances, and a edges attribute which is list of Edge instances. See the documentation of Vertex and Edge for more information. Accessing elements \u00a4 Accessing elements in a DSM or a Package is very easy. Just like for a dictionary, you can use the [] notation to search for a sub-package or a sub-module. You can also use the get method, which is equivalent to the brackets accessor, but will return None if the element is not found whereas brackets accessor will raise a KeyError . Example: from dependenpy import DSM dsm = DSM ( 'django' ) # full DSM object, containing Django django = dsm [ 'django' ] # Django Package object You can use dots in the element name to go further in just one instruction: django_auth = django [ 'contrib.auth' ] django_forms_models = dsm . get ( 'django.forms.models' ) Of course, accesses can be chained: django_db_models_utils = dsm [ 'django' ] . get ( 'db' )[ 'models' ][ 'utils' ] Printing contents \u00a4 Contents of DSMs, packages, modules, matrices, treemaps and graphs can be printed with their print method. The contents printed are the dependencies. With some exception, each one of them can output contents in three different formats: text (by default) CSV JSON (Currently, treemaps are not implemented, and graphs can only be printed in JSON or CSV.) To choose one of these format, just pass the format argument, which accepts values 'text' , 'csv' and 'json' . Please note that these values can be replaced by constants imported from dependenpy.helpers module: from dependenpy import DSM from dependenpy.helpers import TEXT , CSV , JSON dsm = DSM ( 'django' ) dsm . print ( format = JSON ) Depending on the chosen format, additional keyword arguments can be passed to the print method: text format: indent , indentation value (integer) CSV format: header , True or False, to display the headers (columns names) JSON format: every arguments accepted by json.dumps , and in the case of a Module instance, absolute Boolean to switch between output of absolute and relative paths. For DSM and Package instances, shortcuts to print a matrix, a treemap or a graph are available with print_matrix , print_treemap and print_graph methods. These methods will first create the related object and then call the object's own print method.","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#importing-classes","text":"You can directly import the following classes from dependenpy : DSM , Package , Module , Dependency , Matrix and TreeMap . If you need to import other classes, please take a look at the structure of the code. Example: from dependenpy import DSM , Matrix","title":"Importing classes"},{"location":"usage/#creation-of-objects","text":"For basic usage, you only have to instantiate a DSM object, and sometimes Matrix and TreeMap . But if you need to do more complicated stuff, you might also want to build instances of Package , Module or Dependency .","title":"Creation of objects"},{"location":"usage/#create-a-dsm","text":"To create a DSM object, just pass it a list of packages that can be either found on the disk (absolute or relative paths), or in the Python path (like in sys.path ). from dependenpy import DSM django = DSM ( 'django' ) flask = DSM ( 'flask' ) both = DSM ( 'django' , 'flask' ) Three keyword arguments can be given to DSM : build_tree : Boolean build_dependencies : Boolean enforce_init : Boolean The three of them defaults to true. Turning build_tree to false will delay the build of the Python package tree (the exploration of files on the file system). You can later call dsm.build_tree() to build the tree. Turning build_dependencies to false will delay the build of the dependencies (the parsing of the source code to determine the inter-dependencies). You can later call dsm.build_dependencies() to build the dependencies. Note that you won't be able to build the dependencies before the tree has been built. Using true for both build_tree and build_dependencies is recommended since it is done pretty quickly, even for big projects like Django. Turning enforce_init to false will make the exploration of sub-directories complete: by default, a sub-directory is not explored if it does not contain an __init__.py file. It makes the building of the tree faster. But in some cases, you might want to still explore the sub-directory even without __init__.py . In that case, use enforce_init=False . Note that depending on the tree, the build might take longer.","title":"Create a DSM"},{"location":"usage/#create-a-package","text":"To create a Package object, initialize it with a name and a path. These two arguments are the only one required. Name should be the name of the Python package (the name of the directory), and path should be the path to the directory on the file system. Example: from dependenpy import Package absolute_package = Package ( 'django' , '/my/virtualenv/lib/python3.5/site-packages/django' ) relative_package = Package ( 'program' , 'src/program' ) Additionally, you can pass 6 more keyword arguments: the same three from DSM ( build_tree , build_dependencies and enforce_init ), and the three following: dsm : parent DSM (instance of DSM). package : parent package (instance of Package). limit_to : list of strings to limit the exploration to a subset of directories. These three arguments default to None . Both dsm and package arguments are useful to build a tree. Argument limit_to can be used this way: from dependenpy import Package django_auth = Package ( 'django' , 'path/to/django' , limit_to = [ 'contrib.auth' ]) Of course, you could also have build a the django_auth Package by directly specify the name and path of the sub-directory, but using limit_to allows you to build the full tree, starting at the root (Django's directory). from dependenpy import Package django_auth = Package ( 'auth' , 'path/to/django/contrib/auth' )","title":"Create a Package"},{"location":"usage/#create-a-module","text":"To create a Module object, initialize it with a name and a path. These two arguments are the only one required. Name should be the name of the Python module (the file without the .py extension), and path should be the path to the file on the file system. As for Package , dsm and package arguments can be passed when creating a module. Example: from dependenpy import Module dsm_module = Module ( 'dsm' , 'path/to/dependenpy/dsm.py' )","title":"Create a Module"},{"location":"usage/#create-a-dependency","text":"A dependency is a simple object that require: source : the Module instance importing the item, lineno : the line number at which the import occurred, target : the Package or Module instance from which the item is imported and an optional what argument which defaults to None: the name of the imported item.","title":"Create a Dependency"},{"location":"usage/#create-a-matrix","text":"From an instance of DSM or Package called node : matrix = node . as_matrix ( depth = 2 ) From a list of nodes (DSMs, packages or modules): matrix = Matrix ( * node_list , depth = 2 ) An instance of Matrix has a data attribute, which is a two-dimensions array of integers, and a keys attribute which is the list of names, in the same order as rows in data.","title":"Create a Matrix"},{"location":"usage/#create-a-treemap","text":"From an instance of DSM or Package called node : treemap = node . as_treemap ( depth = 2 ) From a list of nodes (DSMs, packages or modules): matrix = TreeMap ( * node_list , depth = 2 ) An instance of TreeMap has a data attribute, which is a two-dimensions array of integers or treemaps, a keys attribute which is the list of names in the same order as rows in data, and a value attribute which is the total number of dependencies in the treemap.","title":"Create a TreeMap"},{"location":"usage/#create-a-graph","text":"From an instance of DSM or Package called node : graph = node . as_graph ( depth = 2 ) From a list of nodes (DSMs, packages or modules): graph = Graph ( * node_list , depth = 2 ) An instance of Graph has a vertices attribute, which is a list of Vertex instances, and a edges attribute which is list of Edge instances. See the documentation of Vertex and Edge for more information.","title":"Create a Graph"},{"location":"usage/#accessing-elements","text":"Accessing elements in a DSM or a Package is very easy. Just like for a dictionary, you can use the [] notation to search for a sub-package or a sub-module. You can also use the get method, which is equivalent to the brackets accessor, but will return None if the element is not found whereas brackets accessor will raise a KeyError . Example: from dependenpy import DSM dsm = DSM ( 'django' ) # full DSM object, containing Django django = dsm [ 'django' ] # Django Package object You can use dots in the element name to go further in just one instruction: django_auth = django [ 'contrib.auth' ] django_forms_models = dsm . get ( 'django.forms.models' ) Of course, accesses can be chained: django_db_models_utils = dsm [ 'django' ] . get ( 'db' )[ 'models' ][ 'utils' ]","title":"Accessing elements"},{"location":"usage/#printing-contents","text":"Contents of DSMs, packages, modules, matrices, treemaps and graphs can be printed with their print method. The contents printed are the dependencies. With some exception, each one of them can output contents in three different formats: text (by default) CSV JSON (Currently, treemaps are not implemented, and graphs can only be printed in JSON or CSV.) To choose one of these format, just pass the format argument, which accepts values 'text' , 'csv' and 'json' . Please note that these values can be replaced by constants imported from dependenpy.helpers module: from dependenpy import DSM from dependenpy.helpers import TEXT , CSV , JSON dsm = DSM ( 'django' ) dsm . print ( format = JSON ) Depending on the chosen format, additional keyword arguments can be passed to the print method: text format: indent , indentation value (integer) CSV format: header , True or False, to display the headers (columns names) JSON format: every arguments accepted by json.dumps , and in the case of a Module instance, absolute Boolean to switch between output of absolute and relative paths. For DSM and Package instances, shortcuts to print a matrix, a treemap or a graph are available with print_matrix , print_treemap and print_graph methods. These methods will first create the related object and then call the object's own print method.","title":"Printing contents"},{"location":"reference/cli/","text":"\u00a4 Module that contains the command line application. get_parser () \u00a4 Return the CLI argument parser. Returns: Type Description ArgumentParser An argparse parser. Source code in dependenpy/cli.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def get_parser () -> argparse . ArgumentParser : \"\"\" Return the CLI argument parser. Returns: An argparse parser. \"\"\" parser = argparse . ArgumentParser ( prog = \"dependenpy\" , add_help = False , description = \"Command line tool for dependenpy Python package.\" ) mxg = parser . add_mutually_exclusive_group ( required = False ) parser . add_argument ( \"packages\" , metavar = \"PACKAGES\" , nargs = argparse . ONE_OR_MORE , help = \"The package list. Can be a comma-separated list. Each package \" \"must be either a valid path or a package in PYTHONPATH.\" , ) parser . add_argument ( \"-d\" , \"--depth\" , default = None , type = int , dest = \"depth\" , help = \"Specify matrix or graph depth. Default: best guess.\" , ) parser . add_argument ( \"-f\" , \"--format\" , choices = FORMAT , default = \"text\" , dest = \"format\" , help = \"Output format. Default: text.\" ) mxg . add_argument ( \"-g\" , \"--show-graph\" , action = \"store_true\" , dest = \"graph\" , default = False , help = \"Show the graph (no text format). Default: false.\" , ) parser . add_argument ( \"-G\" , \"--greedy\" , action = \"store_true\" , dest = \"greedy\" , default = False , help = \"Explore subdirectories even if they do not contain an \" \"__init__.py file. Can make execution slower. Default: false.\" , ) parser . add_argument ( \"-h\" , \"--help\" , action = \"help\" , default = argparse . SUPPRESS , help = \"Show this help message and exit.\" ) parser . add_argument ( \"-i\" , \"--indent\" , default = None , type = int , dest = \"indent\" , help = \"Specify output indentation. CSV will never be indented. \" \"Text will always have new-lines. JSON can be minified with \" \"a negative value. Default: best guess.\" , ) mxg . add_argument ( \"-l\" , \"--show-dependencies-list\" , action = \"store_true\" , dest = \"dependencies\" , default = False , help = \"Show the dependencies list. Default: false.\" , ) mxg . add_argument ( \"-m\" , \"--show-matrix\" , action = \"store_true\" , dest = \"matrix\" , default = False , help = \"Show the matrix. Default: true unless -g, -l or -t.\" , ) parser . add_argument ( \"-o\" , \"--output\" , action = \"store\" , dest = \"output\" , default = sys . stdout , help = \"Output to given file. Default: stdout.\" , ) mxg . add_argument ( \"-t\" , \"--show-treemap\" , action = \"store_true\" , dest = \"treemap\" , default = False , help = \"Show the treemap (work in progress). Default: false.\" , ) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = \"dependenpy %s \" % __version__ , help = \"Show the current version of the program and exit.\" , ) parser . add_argument ( \"-z\" , \"--zero\" , dest = \"zero\" , default = \"0\" , help = \"Character to use for cells with value=0 (text matrix display only).\" , ) return parser main ( args = None ) \u00a4 Run the main program. This function is executed when you type dependenpy or python -m dependenpy . Parameters: Name Type Description Default args Optional[List[str]] Arguments passed from the command line. None Returns: Type Description int An exit code: 0 (OK), 1 (dsm empty) or 2 (error). Source code in dependenpy/cli.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def main ( args : Optional [ List [ str ]] = None ) -> int : \"\"\" Run the main program. This function is executed when you type `dependenpy` or `python -m dependenpy`. Arguments: args: Arguments passed from the command line. Returns: An exit code: 0 (OK), 1 (dsm empty) or 2 (error). \"\"\" parser = get_parser () args = parser . parse_args ( args = args ) if not ( args . matrix or args . dependencies or args . treemap or args . graph ): args . matrix = True # split comma-separated args packages = [] for arg in args . packages : if \",\" in arg : for package in arg . split ( \",\" ): if package not in packages : packages . append ( package ) elif arg not in packages : packages . append ( arg ) # guess convenient depth depth = args . depth if depth is None : depth = guess_depth ( packages ) # open file if not stdout output = args . output if isinstance ( output , str ): output = open ( output , \"w\" ) dsm = DSM ( * packages , build_tree = True , build_dependencies = True , enforce_init = not args . greedy ) if dsm . empty : return 1 indent = args . indent if indent is None : if args . format == CSV : indent = 0 else : indent = 2 elif indent < 0 and args . format == JSON : # special case for json.dumps indent argument indent = None # init colorama init () try : if args . dependencies : dsm . print ( format = args . format , output = output , indent = indent ) elif args . matrix : dsm . print_matrix ( format = args . format , output = output , depth = depth , indent = indent , zero = args . zero ) elif args . treemap : dsm . print_treemap ( format = args . format , output = output ) elif args . graph : dsm . print_graph ( format = args . format , output = output , depth = depth , indent = indent ) except BrokenPipeError : # avoid traceback return 2 return 0","title":"cli.py"},{"location":"reference/cli/#dependenpy.cli","text":"Module that contains the command line application.","title":"dependenpy.cli"},{"location":"reference/cli/#dependenpy.cli.get_parser","text":"Return the CLI argument parser. Returns: Type Description ArgumentParser An argparse parser. Source code in dependenpy/cli.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def get_parser () -> argparse . ArgumentParser : \"\"\" Return the CLI argument parser. Returns: An argparse parser. \"\"\" parser = argparse . ArgumentParser ( prog = \"dependenpy\" , add_help = False , description = \"Command line tool for dependenpy Python package.\" ) mxg = parser . add_mutually_exclusive_group ( required = False ) parser . add_argument ( \"packages\" , metavar = \"PACKAGES\" , nargs = argparse . ONE_OR_MORE , help = \"The package list. Can be a comma-separated list. Each package \" \"must be either a valid path or a package in PYTHONPATH.\" , ) parser . add_argument ( \"-d\" , \"--depth\" , default = None , type = int , dest = \"depth\" , help = \"Specify matrix or graph depth. Default: best guess.\" , ) parser . add_argument ( \"-f\" , \"--format\" , choices = FORMAT , default = \"text\" , dest = \"format\" , help = \"Output format. Default: text.\" ) mxg . add_argument ( \"-g\" , \"--show-graph\" , action = \"store_true\" , dest = \"graph\" , default = False , help = \"Show the graph (no text format). Default: false.\" , ) parser . add_argument ( \"-G\" , \"--greedy\" , action = \"store_true\" , dest = \"greedy\" , default = False , help = \"Explore subdirectories even if they do not contain an \" \"__init__.py file. Can make execution slower. Default: false.\" , ) parser . add_argument ( \"-h\" , \"--help\" , action = \"help\" , default = argparse . SUPPRESS , help = \"Show this help message and exit.\" ) parser . add_argument ( \"-i\" , \"--indent\" , default = None , type = int , dest = \"indent\" , help = \"Specify output indentation. CSV will never be indented. \" \"Text will always have new-lines. JSON can be minified with \" \"a negative value. Default: best guess.\" , ) mxg . add_argument ( \"-l\" , \"--show-dependencies-list\" , action = \"store_true\" , dest = \"dependencies\" , default = False , help = \"Show the dependencies list. Default: false.\" , ) mxg . add_argument ( \"-m\" , \"--show-matrix\" , action = \"store_true\" , dest = \"matrix\" , default = False , help = \"Show the matrix. Default: true unless -g, -l or -t.\" , ) parser . add_argument ( \"-o\" , \"--output\" , action = \"store\" , dest = \"output\" , default = sys . stdout , help = \"Output to given file. Default: stdout.\" , ) mxg . add_argument ( \"-t\" , \"--show-treemap\" , action = \"store_true\" , dest = \"treemap\" , default = False , help = \"Show the treemap (work in progress). Default: false.\" , ) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = \"dependenpy %s \" % __version__ , help = \"Show the current version of the program and exit.\" , ) parser . add_argument ( \"-z\" , \"--zero\" , dest = \"zero\" , default = \"0\" , help = \"Character to use for cells with value=0 (text matrix display only).\" , ) return parser","title":"get_parser()"},{"location":"reference/cli/#dependenpy.cli.main","text":"Run the main program. This function is executed when you type dependenpy or python -m dependenpy . Parameters: Name Type Description Default args Optional[List[str]] Arguments passed from the command line. None Returns: Type Description int An exit code: 0 (OK), 1 (dsm empty) or 2 (error). Source code in dependenpy/cli.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def main ( args : Optional [ List [ str ]] = None ) -> int : \"\"\" Run the main program. This function is executed when you type `dependenpy` or `python -m dependenpy`. Arguments: args: Arguments passed from the command line. Returns: An exit code: 0 (OK), 1 (dsm empty) or 2 (error). \"\"\" parser = get_parser () args = parser . parse_args ( args = args ) if not ( args . matrix or args . dependencies or args . treemap or args . graph ): args . matrix = True # split comma-separated args packages = [] for arg in args . packages : if \",\" in arg : for package in arg . split ( \",\" ): if package not in packages : packages . append ( package ) elif arg not in packages : packages . append ( arg ) # guess convenient depth depth = args . depth if depth is None : depth = guess_depth ( packages ) # open file if not stdout output = args . output if isinstance ( output , str ): output = open ( output , \"w\" ) dsm = DSM ( * packages , build_tree = True , build_dependencies = True , enforce_init = not args . greedy ) if dsm . empty : return 1 indent = args . indent if indent is None : if args . format == CSV : indent = 0 else : indent = 2 elif indent < 0 and args . format == JSON : # special case for json.dumps indent argument indent = None # init colorama init () try : if args . dependencies : dsm . print ( format = args . format , output = output , indent = indent ) elif args . matrix : dsm . print_matrix ( format = args . format , output = output , depth = depth , indent = indent , zero = args . zero ) elif args . treemap : dsm . print_treemap ( format = args . format , output = output ) elif args . graph : dsm . print_graph ( format = args . format , output = output , depth = depth , indent = indent ) except BrokenPipeError : # avoid traceback return 2 return 0","title":"main()"},{"location":"reference/dsm/","text":"\u00a4 dependenpy dsm module. This is the core module of dependenpy. It contains the following classes: :class: DSM : to create a DSM-capable object for a list of packages, :class: Package : which represents a Python package, :class: Module : which represents a Python module, :class: Dependency : which represents a dependency between two modules. Dependency \u00a4 Dependency class. Represent a dependency from a module to another. external property readonly \u00a4 Property to tell if the dependency's target is a valid node. __init__ ( self , source , lineno , target , what = None ) special \u00a4 Initialization method. Parameters: Name Type Description Default source Module source Module. required lineno int number of line at which import statement occurs. required target str/Module/Package the target node. required what str what is imported (optional). None Source code in dependenpy/dsm.py 420 421 422 423 424 425 426 427 428 429 430 431 432 433 def __init__ ( self , source , lineno , target , what = None ): \"\"\" Initialization method. Args: source (Module): source Module. lineno (int): number of line at which import statement occurs. target (str/Module/Package): the target node. what (str): what is imported (optional). \"\"\" self . source = source self . lineno = lineno self . target = target self . what = what DSM \u00a4 DSM-capable class. Technically speaking, a DSM instance is not a real DSM but more a tree representing the Python packages structure. However, it has the necessary methods to build a real DSM in the form of a square matrix, a dictionary or a tree-map. isdsm property readonly \u00a4 Inherited from NodeMixin. Always True. __init__ ( self , * packages , * , build_tree = True , build_dependencies = True , enforce_init = True ) special \u00a4 Initialization method. Parameters: Name Type Description Default *packages args list of packages to search for. () build_tree bool auto-build the tree or not. True build_dependencies bool auto-build the dependencies or not. True enforce_init bool if True, only treat directories if they contain an __init__.py file. True Source code in dependenpy/dsm.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def __init__ ( self , * packages , build_tree = True , build_dependencies = True , enforce_init = True ): \"\"\" Initialization method. Args: *packages (args): list of packages to search for. build_tree (bool): auto-build the tree or not. build_dependencies (bool): auto-build the dependencies or not. enforce_init (bool): if True, only treat directories if they contain an ``__init__.py`` file. \"\"\" self . finder = Finder () self . specs = [] self . not_found = [] self . enforce_init = enforce_init specs = [] for package in packages : spec = self . finder . find ( package , enforce_init = enforce_init ) if spec : specs . append ( spec ) else : self . not_found . append ( package ) if not specs : print ( \"** dependenpy: DSM empty.\" , file = sys . stderr ) self . specs = PackageSpec . combine ( specs ) for m in self . not_found : print ( \"** dependenpy: Not found: %s .\" % m , file = sys . stderr ) super () . __init__ ( build_tree ) if build_tree and build_dependencies : self . build_dependencies () build_tree ( self ) \u00a4 Build the Python packages tree. Source code in dependenpy/dsm.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def build_tree ( self ): \"\"\"Build the Python packages tree.\"\"\" for spec in self . specs : if spec . ismodule : self . modules . append ( Module ( spec . name , spec . path , dsm = self )) else : self . packages . append ( Package ( spec . name , spec . path , dsm = self , limit_to = spec . limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) ) Module \u00a4 Module class. This class represents a Python module (a Python file). ismodule property readonly \u00a4 Inherited from NodeMixin. Always True. __contains__ ( self , item ) special \u00a4 Whether given item is contained inside this module. Parameters: Name Type Description Default item Package/Module a package or module. required Returns: Type Description bool True if self is item or item is self's package and self if an __init__ module. Source code in dependenpy/dsm.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 def __contains__ ( self , item ): \"\"\" Whether given item is contained inside this module. Args: item (Package/Module): a package or module. Returns: bool: True if self is item or item is self's package and self if an ``__init__`` module. \"\"\" if self is item : return True elif self . package is item and self . name == \"__init__\" : return True return False __init__ ( self , name , path , dsm = None , package = None ) special \u00a4 Initialization method. Parameters: Name Type Description Default name str name of the module. required path str path to the module. required dsm DSM parent DSM. None package Package parent Package. None Source code in dependenpy/dsm.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def __init__ ( self , name , path , dsm = None , package = None ): \"\"\" Initialization method. Args: name (str): name of the module. path (str): path to the module. dsm (DSM): parent DSM. package (Package): parent Package. \"\"\" super () . __init__ () self . name = name self . path = path self . package = package self . dsm = dsm self . dependencies = [] as_dict ( self , absolute = False ) \u00a4 Return the dependencies as a dictionary. Returns: Type Description dict dictionary of dependencies. Source code in dependenpy/dsm.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def as_dict ( self , absolute = False ): \"\"\" Return the dependencies as a dictionary. Returns: dict: dictionary of dependencies. \"\"\" return { \"name\" : self . absolute_name () if absolute else self . name , \"path\" : self . path , \"dependencies\" : [ { # 'source': d.source.absolute_name(), # redundant \"target\" : d . target if d . external else d . target . absolute_name (), \"lineno\" : d . lineno , \"what\" : d . what , \"external\" : d . external , } for d in self . dependencies ], } build_dependencies ( self ) \u00a4 Build the dependencies for this module. Parse the code with ast, find all the import statements, convert them into Dependency objects. Source code in dependenpy/dsm.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 def build_dependencies ( self ): \"\"\" Build the dependencies for this module. Parse the code with ast, find all the import statements, convert them into Dependency objects. \"\"\" highest = self . dsm or self . root if self is highest : highest = LeafNode () for _import in self . parse_code (): target = highest . get_target ( _import [ \"target\" ]) if target : what = _import [ \"target\" ] . split ( \".\" )[ - 1 ] if what != target . name : _import [ \"what\" ] = what _import [ \"target\" ] = target self . dependencies . append ( Dependency ( source = self , ** _import )) cardinal ( self , to ) \u00a4 Return the number of dependencies of this module to the given node. Parameters: Name Type Description Default to Package/Module the target node. required Returns: Type Description int number of dependencies. Source code in dependenpy/dsm.py 400 401 402 403 404 405 406 407 408 409 410 def cardinal ( self , to ): \"\"\" Return the number of dependencies of this module to the given node. Args: to (Package/Module): the target node. Returns: int: number of dependencies. \"\"\" return sum ( 1 for _ in filter ( lambda d : not d . external and d . target in to , self . dependencies )) get_imports ( self , ast_body ) \u00a4 Return all the import statements given an AST body (AST nodes). Parameters: Name Type Description Default ast_body compiled code's body the body to filter. required Returns: Type Description list of dict the import statements. Source code in dependenpy/dsm.py 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def get_imports ( self , ast_body ): \"\"\" Return all the import statements given an AST body (AST nodes). Args: ast_body (compiled code's body): the body to filter. Returns: list of dict: the import statements. \"\"\" imports = [] for node in ast_body : if isinstance ( node , ast . Import ): imports . extend ({ \"target\" : name . name , \"lineno\" : node . lineno } for name in node . names ) elif isinstance ( node , ast . ImportFrom ): for name in node . names : name = ( ( self . absolute_name ( self . depth - node . level ) + \".\" if node . level > 0 else \"\" ) + ( node . module + \".\" if node . module else \"\" ) + name . name ) imports . append ({ \"target\" : name , \"lineno\" : node . lineno }) elif isinstance ( node , Module . RECURSIVE_NODES ): imports . extend ( self . get_imports ( node . body )) if isinstance ( node , ast . Try ): imports . extend ( self . get_imports ( node . finalbody )) return imports parse_code ( self ) \u00a4 Read the source code and return all the import statements. Returns: Type Description list of dict the import statements. Source code in dependenpy/dsm.py 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def parse_code ( self ): \"\"\" Read the source code and return all the import statements. Returns: list of dict: the import statements. \"\"\" code = open ( self . path , encoding = \"utf-8\" ) . read () try : body = ast . parse ( code ) . body except SyntaxError : try : code = code . encode ( \"utf-8\" ) body = ast . parse ( code ) . body except SyntaxError : return [] return self . get_imports ( body ) Package \u00a4 Package class. This class represent Python packages as nodes in a tree. ispackage property readonly \u00a4 Inherited from NodeMixin. Always True. isroot property readonly \u00a4 Property to tell if this node is a root node. Returns: Type Description bool this package has no parent. issubpackage property readonly \u00a4 Property to tell if this node is a sub-package. Returns: Type Description bool this package has a parent. __init__ ( self , name , path , dsm = None , package = None , limit_to = None , build_tree = True , build_dependencies = True , enforce_init = True ) special \u00a4 Initialization method. Parameters: Name Type Description Default name str name of the package. required path str path to the package. required dsm DSM parent DSM. None package Package parent package. None limit_to list of str list of string to limit the recursive tree-building to what is specified. None build_tree bool auto-build the tree or not. True build_dependencies bool auto-build the dependencies or not. True enforce_init bool if True, only treat directories if they contain an __init__.py file. True Source code in dependenpy/dsm.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def __init__ ( self , name , path , dsm = None , package = None , limit_to = None , build_tree = True , build_dependencies = True , enforce_init = True , ): \"\"\" Initialization method. Args: name (str): name of the package. path (str): path to the package. dsm (DSM): parent DSM. package (Package): parent package. limit_to (list of str): list of string to limit the recursive tree-building to what is specified. build_tree (bool): auto-build the tree or not. build_dependencies (bool): auto-build the dependencies or not. enforce_init (bool): if True, only treat directories if they contain an ``__init__.py`` file. \"\"\" self . name = name self . path = path self . package = package self . dsm = dsm self . limit_to = limit_to or [] self . enforce_init = enforce_init RootNode . __init__ ( self , build_tree ) LeafNode . __init__ ( self ) if build_tree and build_dependencies : self . build_dependencies () build_tree ( self ) \u00a4 Build the tree for this package. Source code in dependenpy/dsm.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 def build_tree ( self ): \"\"\"Build the tree for this package.\"\"\" for m in listdir ( self . path ): abs_m = join ( self . path , m ) if isfile ( abs_m ) and m . endswith ( \".py\" ): name = splitext ( m )[ 0 ] if not self . limit_to or name in self . limit_to : self . modules . append ( Module ( name , abs_m , self . dsm , self )) elif isdir ( abs_m ): if isfile ( join ( abs_m , \"__init__.py\" )) or not self . enforce_init : heads , new_limit_to = self . split_limits_heads () if not heads or m in heads : self . packages . append ( Package ( m , abs_m , self . dsm , self , new_limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) ) cardinal ( self , to ) \u00a4 Return the number of dependencies of this package to the given node. Parameters: Name Type Description Default to Package/Module target node. required Returns: Type Description int number of dependencies. Source code in dependenpy/dsm.py 216 217 218 219 220 221 222 223 224 225 226 def cardinal ( self , to ): \"\"\" Return the number of dependencies of this package to the given node. Args: to (Package/Module): target node. Returns: int: number of dependencies. \"\"\" return sum ( m . cardinal ( to ) for m in self . submodules ) split_limits_heads ( self ) \u00a4 Return first parts of dot-separated strings, and rest of strings. Returns: Type Description (list of str, list of str) the heads and rest of the strings. Source code in dependenpy/dsm.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def split_limits_heads ( self ): \"\"\" Return first parts of dot-separated strings, and rest of strings. Returns: (list of str, list of str): the heads and rest of the strings. \"\"\" heads = [] new_limit_to = [] for limit in self . limit_to : if \".\" in limit : name , limit = limit . split ( \".\" , 1 ) heads . append ( name ) new_limit_to . append ( limit ) else : heads . append ( limit ) return heads , new_limit_to","title":"dsm.py"},{"location":"reference/dsm/#dependenpy.dsm","text":"dependenpy dsm module. This is the core module of dependenpy. It contains the following classes: :class: DSM : to create a DSM-capable object for a list of packages, :class: Package : which represents a Python package, :class: Module : which represents a Python module, :class: Dependency : which represents a dependency between two modules.","title":"dependenpy.dsm"},{"location":"reference/dsm/#dependenpy.dsm.Dependency","text":"Dependency class. Represent a dependency from a module to another.","title":"Dependency"},{"location":"reference/dsm/#dependenpy.dsm.Dependency.external","text":"Property to tell if the dependency's target is a valid node.","title":"external"},{"location":"reference/dsm/#dependenpy.dsm.Dependency.__init__","text":"Initialization method. Parameters: Name Type Description Default source Module source Module. required lineno int number of line at which import statement occurs. required target str/Module/Package the target node. required what str what is imported (optional). None Source code in dependenpy/dsm.py 420 421 422 423 424 425 426 427 428 429 430 431 432 433 def __init__ ( self , source , lineno , target , what = None ): \"\"\" Initialization method. Args: source (Module): source Module. lineno (int): number of line at which import statement occurs. target (str/Module/Package): the target node. what (str): what is imported (optional). \"\"\" self . source = source self . lineno = lineno self . target = target self . what = what","title":"__init__()"},{"location":"reference/dsm/#dependenpy.dsm.DSM","text":"DSM-capable class. Technically speaking, a DSM instance is not a real DSM but more a tree representing the Python packages structure. However, it has the necessary methods to build a real DSM in the form of a square matrix, a dictionary or a tree-map.","title":"DSM"},{"location":"reference/dsm/#dependenpy.dsm.DSM.isdsm","text":"Inherited from NodeMixin. Always True.","title":"isdsm"},{"location":"reference/dsm/#dependenpy.dsm.DSM.__init__","text":"Initialization method. Parameters: Name Type Description Default *packages args list of packages to search for. () build_tree bool auto-build the tree or not. True build_dependencies bool auto-build the dependencies or not. True enforce_init bool if True, only treat directories if they contain an __init__.py file. True Source code in dependenpy/dsm.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def __init__ ( self , * packages , build_tree = True , build_dependencies = True , enforce_init = True ): \"\"\" Initialization method. Args: *packages (args): list of packages to search for. build_tree (bool): auto-build the tree or not. build_dependencies (bool): auto-build the dependencies or not. enforce_init (bool): if True, only treat directories if they contain an ``__init__.py`` file. \"\"\" self . finder = Finder () self . specs = [] self . not_found = [] self . enforce_init = enforce_init specs = [] for package in packages : spec = self . finder . find ( package , enforce_init = enforce_init ) if spec : specs . append ( spec ) else : self . not_found . append ( package ) if not specs : print ( \"** dependenpy: DSM empty.\" , file = sys . stderr ) self . specs = PackageSpec . combine ( specs ) for m in self . not_found : print ( \"** dependenpy: Not found: %s .\" % m , file = sys . stderr ) super () . __init__ ( build_tree ) if build_tree and build_dependencies : self . build_dependencies ()","title":"__init__()"},{"location":"reference/dsm/#dependenpy.dsm.DSM.build_tree","text":"Build the Python packages tree. Source code in dependenpy/dsm.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def build_tree ( self ): \"\"\"Build the Python packages tree.\"\"\" for spec in self . specs : if spec . ismodule : self . modules . append ( Module ( spec . name , spec . path , dsm = self )) else : self . packages . append ( Package ( spec . name , spec . path , dsm = self , limit_to = spec . limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) )","title":"build_tree()"},{"location":"reference/dsm/#dependenpy.dsm.Module","text":"Module class. This class represents a Python module (a Python file).","title":"Module"},{"location":"reference/dsm/#dependenpy.dsm.Module.ismodule","text":"Inherited from NodeMixin. Always True.","title":"ismodule"},{"location":"reference/dsm/#dependenpy.dsm.Module.__contains__","text":"Whether given item is contained inside this module. Parameters: Name Type Description Default item Package/Module a package or module. required Returns: Type Description bool True if self is item or item is self's package and self if an __init__ module. Source code in dependenpy/dsm.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 def __contains__ ( self , item ): \"\"\" Whether given item is contained inside this module. Args: item (Package/Module): a package or module. Returns: bool: True if self is item or item is self's package and self if an ``__init__`` module. \"\"\" if self is item : return True elif self . package is item and self . name == \"__init__\" : return True return False","title":"__contains__()"},{"location":"reference/dsm/#dependenpy.dsm.Module.__init__","text":"Initialization method. Parameters: Name Type Description Default name str name of the module. required path str path to the module. required dsm DSM parent DSM. None package Package parent Package. None Source code in dependenpy/dsm.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def __init__ ( self , name , path , dsm = None , package = None ): \"\"\" Initialization method. Args: name (str): name of the module. path (str): path to the module. dsm (DSM): parent DSM. package (Package): parent Package. \"\"\" super () . __init__ () self . name = name self . path = path self . package = package self . dsm = dsm self . dependencies = []","title":"__init__()"},{"location":"reference/dsm/#dependenpy.dsm.Module.as_dict","text":"Return the dependencies as a dictionary. Returns: Type Description dict dictionary of dependencies. Source code in dependenpy/dsm.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def as_dict ( self , absolute = False ): \"\"\" Return the dependencies as a dictionary. Returns: dict: dictionary of dependencies. \"\"\" return { \"name\" : self . absolute_name () if absolute else self . name , \"path\" : self . path , \"dependencies\" : [ { # 'source': d.source.absolute_name(), # redundant \"target\" : d . target if d . external else d . target . absolute_name (), \"lineno\" : d . lineno , \"what\" : d . what , \"external\" : d . external , } for d in self . dependencies ], }","title":"as_dict()"},{"location":"reference/dsm/#dependenpy.dsm.Module.build_dependencies","text":"Build the dependencies for this module. Parse the code with ast, find all the import statements, convert them into Dependency objects. Source code in dependenpy/dsm.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 def build_dependencies ( self ): \"\"\" Build the dependencies for this module. Parse the code with ast, find all the import statements, convert them into Dependency objects. \"\"\" highest = self . dsm or self . root if self is highest : highest = LeafNode () for _import in self . parse_code (): target = highest . get_target ( _import [ \"target\" ]) if target : what = _import [ \"target\" ] . split ( \".\" )[ - 1 ] if what != target . name : _import [ \"what\" ] = what _import [ \"target\" ] = target self . dependencies . append ( Dependency ( source = self , ** _import ))","title":"build_dependencies()"},{"location":"reference/dsm/#dependenpy.dsm.Module.cardinal","text":"Return the number of dependencies of this module to the given node. Parameters: Name Type Description Default to Package/Module the target node. required Returns: Type Description int number of dependencies. Source code in dependenpy/dsm.py 400 401 402 403 404 405 406 407 408 409 410 def cardinal ( self , to ): \"\"\" Return the number of dependencies of this module to the given node. Args: to (Package/Module): the target node. Returns: int: number of dependencies. \"\"\" return sum ( 1 for _ in filter ( lambda d : not d . external and d . target in to , self . dependencies ))","title":"cardinal()"},{"location":"reference/dsm/#dependenpy.dsm.Module.get_imports","text":"Return all the import statements given an AST body (AST nodes). Parameters: Name Type Description Default ast_body compiled code's body the body to filter. required Returns: Type Description list of dict the import statements. Source code in dependenpy/dsm.py 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def get_imports ( self , ast_body ): \"\"\" Return all the import statements given an AST body (AST nodes). Args: ast_body (compiled code's body): the body to filter. Returns: list of dict: the import statements. \"\"\" imports = [] for node in ast_body : if isinstance ( node , ast . Import ): imports . extend ({ \"target\" : name . name , \"lineno\" : node . lineno } for name in node . names ) elif isinstance ( node , ast . ImportFrom ): for name in node . names : name = ( ( self . absolute_name ( self . depth - node . level ) + \".\" if node . level > 0 else \"\" ) + ( node . module + \".\" if node . module else \"\" ) + name . name ) imports . append ({ \"target\" : name , \"lineno\" : node . lineno }) elif isinstance ( node , Module . RECURSIVE_NODES ): imports . extend ( self . get_imports ( node . body )) if isinstance ( node , ast . Try ): imports . extend ( self . get_imports ( node . finalbody )) return imports","title":"get_imports()"},{"location":"reference/dsm/#dependenpy.dsm.Module.parse_code","text":"Read the source code and return all the import statements. Returns: Type Description list of dict the import statements. Source code in dependenpy/dsm.py 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def parse_code ( self ): \"\"\" Read the source code and return all the import statements. Returns: list of dict: the import statements. \"\"\" code = open ( self . path , encoding = \"utf-8\" ) . read () try : body = ast . parse ( code ) . body except SyntaxError : try : code = code . encode ( \"utf-8\" ) body = ast . parse ( code ) . body except SyntaxError : return [] return self . get_imports ( body )","title":"parse_code()"},{"location":"reference/dsm/#dependenpy.dsm.Package","text":"Package class. This class represent Python packages as nodes in a tree.","title":"Package"},{"location":"reference/dsm/#dependenpy.dsm.Package.ispackage","text":"Inherited from NodeMixin. Always True.","title":"ispackage"},{"location":"reference/dsm/#dependenpy.dsm.Package.isroot","text":"Property to tell if this node is a root node. Returns: Type Description bool this package has no parent.","title":"isroot"},{"location":"reference/dsm/#dependenpy.dsm.Package.issubpackage","text":"Property to tell if this node is a sub-package. Returns: Type Description bool this package has a parent.","title":"issubpackage"},{"location":"reference/dsm/#dependenpy.dsm.Package.__init__","text":"Initialization method. Parameters: Name Type Description Default name str name of the package. required path str path to the package. required dsm DSM parent DSM. None package Package parent package. None limit_to list of str list of string to limit the recursive tree-building to what is specified. None build_tree bool auto-build the tree or not. True build_dependencies bool auto-build the dependencies or not. True enforce_init bool if True, only treat directories if they contain an __init__.py file. True Source code in dependenpy/dsm.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def __init__ ( self , name , path , dsm = None , package = None , limit_to = None , build_tree = True , build_dependencies = True , enforce_init = True , ): \"\"\" Initialization method. Args: name (str): name of the package. path (str): path to the package. dsm (DSM): parent DSM. package (Package): parent package. limit_to (list of str): list of string to limit the recursive tree-building to what is specified. build_tree (bool): auto-build the tree or not. build_dependencies (bool): auto-build the dependencies or not. enforce_init (bool): if True, only treat directories if they contain an ``__init__.py`` file. \"\"\" self . name = name self . path = path self . package = package self . dsm = dsm self . limit_to = limit_to or [] self . enforce_init = enforce_init RootNode . __init__ ( self , build_tree ) LeafNode . __init__ ( self ) if build_tree and build_dependencies : self . build_dependencies ()","title":"__init__()"},{"location":"reference/dsm/#dependenpy.dsm.Package.build_tree","text":"Build the tree for this package. Source code in dependenpy/dsm.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 def build_tree ( self ): \"\"\"Build the tree for this package.\"\"\" for m in listdir ( self . path ): abs_m = join ( self . path , m ) if isfile ( abs_m ) and m . endswith ( \".py\" ): name = splitext ( m )[ 0 ] if not self . limit_to or name in self . limit_to : self . modules . append ( Module ( name , abs_m , self . dsm , self )) elif isdir ( abs_m ): if isfile ( join ( abs_m , \"__init__.py\" )) or not self . enforce_init : heads , new_limit_to = self . split_limits_heads () if not heads or m in heads : self . packages . append ( Package ( m , abs_m , self . dsm , self , new_limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) )","title":"build_tree()"},{"location":"reference/dsm/#dependenpy.dsm.Package.cardinal","text":"Return the number of dependencies of this package to the given node. Parameters: Name Type Description Default to Package/Module target node. required Returns: Type Description int number of dependencies. Source code in dependenpy/dsm.py 216 217 218 219 220 221 222 223 224 225 226 def cardinal ( self , to ): \"\"\" Return the number of dependencies of this package to the given node. Args: to (Package/Module): target node. Returns: int: number of dependencies. \"\"\" return sum ( m . cardinal ( to ) for m in self . submodules )","title":"cardinal()"},{"location":"reference/dsm/#dependenpy.dsm.Package.split_limits_heads","text":"Return first parts of dot-separated strings, and rest of strings. Returns: Type Description (list of str, list of str) the heads and rest of the strings. Source code in dependenpy/dsm.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def split_limits_heads ( self ): \"\"\" Return first parts of dot-separated strings, and rest of strings. Returns: (list of str, list of str): the heads and rest of the strings. \"\"\" heads = [] new_limit_to = [] for limit in self . limit_to : if \".\" in limit : name , limit = limit . split ( \".\" , 1 ) heads . append ( name ) new_limit_to . append ( limit ) else : heads . append ( limit ) return heads , new_limit_to","title":"split_limits_heads()"},{"location":"reference/finder/","text":"\u00a4 dependenpy finder module. Finder \u00a4 Main package finder class. Initialize it with a list of package finder classes (not instances). __init__ ( self , finders = None ) special \u00a4 Initialization method. Parameters: Name Type Description Default finders list of classes list of package finder classes (not instances) in a specific order. Default: [LocalPackageFinder, InstalledPackageFinder]. None Source code in dependenpy/finder.py 149 150 151 152 153 154 155 156 157 158 159 160 161 def __init__ ( self , finders = None ): \"\"\" Initialization method. Args: finders (list of classes): list of package finder classes (not instances) in a specific order. Default: [LocalPackageFinder, InstalledPackageFinder]. \"\"\" if finders is None : self . finders = [ LocalPackageFinder (), InstalledPackageFinder ()] else : self . finders = [ f () for f in finders ] find ( self , package , ** kwargs ) \u00a4 Find a package using package finders. Return the first package found. Parameters: Name Type Description Default package str package to find. required **kwargs additional keyword arguments used by finders. {} Returns: Type Description PackageSpec if package found, else None Source code in dependenpy/finder.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def find ( self , package , ** kwargs ): \"\"\" Find a package using package finders. Return the first package found. Args: package (str): package to find. **kwargs (): additional keyword arguments used by finders. Returns: PackageSpec: if package found, else None \"\"\" for finder in self . finders : package_spec = finder . find ( package , ** kwargs ) if package_spec : return package_spec return None InstalledPackageFinder \u00a4 Finder to find installed Python packages using importlib. find ( self , package , ** kwargs ) \u00a4 Find method. Parameters: Name Type Description Default package str package to find. required **kwargs additional keyword arguments. {} Returns: Type Description PackageSpec the PackageSpec corresponding to the package, or None. Source code in dependenpy/finder.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def find ( self , package , ** kwargs ): \"\"\" Find method. Args: package (str): package to find. **kwargs (): additional keyword arguments. Returns: PackageSpec: the PackageSpec corresponding to the package, or None. \"\"\" spec = find_spec ( package ) if spec is None : return None limit = [] if \".\" in package : package , limit = package . split ( \".\" , 1 ) limit = [ limit ] spec = find_spec ( package ) if spec is not None : if spec . submodule_search_locations : path = spec . submodule_search_locations [ 0 ] elif spec . origin and spec . origin != \"built-in\" : path = spec . origin else : return None return PackageSpec ( spec . name , path , limit ) return None LocalPackageFinder \u00a4 Finder to find local packages (directories on the disk). find ( self , package , ** kwargs ) \u00a4 Find method. Parameters: Name Type Description Default package str package to find. required **kwargs additional keyword arguments. {} Returns: Type Description PackageSpec the PackageSpec corresponding to the package, or None. Source code in dependenpy/finder.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def find ( self , package , ** kwargs ): \"\"\" Find method. Args: package (str): package to find. **kwargs (): additional keyword arguments. Returns: PackageSpec: the PackageSpec corresponding to the package, or None. \"\"\" if not exists ( package ): return None name , path = None , None enforce_init = kwargs . pop ( \"enforce_init\" , True ) if isdir ( package ): if isfile ( join ( package , \"__init__.py\" )) or not enforce_init : name , path = basename ( package ), package elif isfile ( package ) and package . endswith ( \".py\" ): name , path = splitext ( basename ( package ))[ 0 ], package if name and path : return PackageSpec ( name , path ) return None PackageFinder \u00a4 Abstract package finder class. find ( self , package , ** kwargs ) \u00a4 Find method. Parameters: Name Type Description Default package str package to find. required **kwargs additional keyword arguments. {} Returns: Type Description PackageSpec the PackageSpec corresponding to the package, or None. Source code in dependenpy/finder.py 67 68 69 70 71 72 73 74 75 76 77 78 def find ( self , package , ** kwargs ): \"\"\" Find method. Args: package (str): package to find. **kwargs (): additional keyword arguments. Returns: PackageSpec: the PackageSpec corresponding to the package, or None. \"\"\" raise NotImplementedError PackageSpec \u00a4 Holder for a package specification (given as argument to DSM). ismodule property readonly \u00a4 Property to tell if the package is in fact a module (a file). __init__ ( self , name , path , limit_to = None ) special \u00a4 Initialization method. Parameters: Name Type Description Default name str name of the package. required path str path to the package. required limit_to list of str limitations. None Source code in dependenpy/finder.py 12 13 14 15 16 17 18 19 20 21 22 23 def __init__ ( self , name , path , limit_to = None ): \"\"\" Initialization method. Args: name (str): name of the package. path (str): path to the package. limit_to (list of str): limitations. \"\"\" self . name = name self . path = path self . limit_to = limit_to or [] add ( self , spec ) \u00a4 Add limitations of given spec to self's. Parameters: Name Type Description Default spec PackageSpec another spec. required Source code in dependenpy/finder.py 33 34 35 36 37 38 39 40 41 42 def add ( self , spec ): \"\"\" Add limitations of given spec to self's. Args: spec (PackageSpec): another spec. \"\"\" for limit in spec . limit_to : if limit not in self . limit_to : self . limit_to . append ( limit ) combine ( specs ) staticmethod \u00a4 Combine package specifications' limitations. Parameters: Name Type Description Default specs list of PackageSpec the package specifications. required Returns: Type Description list of PackageSpec the new, merged list of PackageSpec. Source code in dependenpy/finder.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @staticmethod def combine ( specs ): \"\"\" Combine package specifications' limitations. Args: specs (list of PackageSpec): the package specifications. Returns: list of PackageSpec: the new, merged list of PackageSpec. \"\"\" new_specs = {} for spec in specs : if new_specs . get ( spec , None ) is None : new_specs [ spec ] = spec else : new_specs [ spec ] . add ( spec ) return list ( new_specs . values ())","title":"finder.py"},{"location":"reference/finder/#dependenpy.finder","text":"dependenpy finder module.","title":"dependenpy.finder"},{"location":"reference/finder/#dependenpy.finder.Finder","text":"Main package finder class. Initialize it with a list of package finder classes (not instances).","title":"Finder"},{"location":"reference/finder/#dependenpy.finder.Finder.__init__","text":"Initialization method. Parameters: Name Type Description Default finders list of classes list of package finder classes (not instances) in a specific order. Default: [LocalPackageFinder, InstalledPackageFinder]. None Source code in dependenpy/finder.py 149 150 151 152 153 154 155 156 157 158 159 160 161 def __init__ ( self , finders = None ): \"\"\" Initialization method. Args: finders (list of classes): list of package finder classes (not instances) in a specific order. Default: [LocalPackageFinder, InstalledPackageFinder]. \"\"\" if finders is None : self . finders = [ LocalPackageFinder (), InstalledPackageFinder ()] else : self . finders = [ f () for f in finders ]","title":"__init__()"},{"location":"reference/finder/#dependenpy.finder.Finder.find","text":"Find a package using package finders. Return the first package found. Parameters: Name Type Description Default package str package to find. required **kwargs additional keyword arguments used by finders. {} Returns: Type Description PackageSpec if package found, else None Source code in dependenpy/finder.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def find ( self , package , ** kwargs ): \"\"\" Find a package using package finders. Return the first package found. Args: package (str): package to find. **kwargs (): additional keyword arguments used by finders. Returns: PackageSpec: if package found, else None \"\"\" for finder in self . finders : package_spec = finder . find ( package , ** kwargs ) if package_spec : return package_spec return None","title":"find()"},{"location":"reference/finder/#dependenpy.finder.InstalledPackageFinder","text":"Finder to find installed Python packages using importlib.","title":"InstalledPackageFinder"},{"location":"reference/finder/#dependenpy.finder.InstalledPackageFinder.find","text":"Find method. Parameters: Name Type Description Default package str package to find. required **kwargs additional keyword arguments. {} Returns: Type Description PackageSpec the PackageSpec corresponding to the package, or None. Source code in dependenpy/finder.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def find ( self , package , ** kwargs ): \"\"\" Find method. Args: package (str): package to find. **kwargs (): additional keyword arguments. Returns: PackageSpec: the PackageSpec corresponding to the package, or None. \"\"\" spec = find_spec ( package ) if spec is None : return None limit = [] if \".\" in package : package , limit = package . split ( \".\" , 1 ) limit = [ limit ] spec = find_spec ( package ) if spec is not None : if spec . submodule_search_locations : path = spec . submodule_search_locations [ 0 ] elif spec . origin and spec . origin != \"built-in\" : path = spec . origin else : return None return PackageSpec ( spec . name , path , limit ) return None","title":"find()"},{"location":"reference/finder/#dependenpy.finder.LocalPackageFinder","text":"Finder to find local packages (directories on the disk).","title":"LocalPackageFinder"},{"location":"reference/finder/#dependenpy.finder.LocalPackageFinder.find","text":"Find method. Parameters: Name Type Description Default package str package to find. required **kwargs additional keyword arguments. {} Returns: Type Description PackageSpec the PackageSpec corresponding to the package, or None. Source code in dependenpy/finder.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def find ( self , package , ** kwargs ): \"\"\" Find method. Args: package (str): package to find. **kwargs (): additional keyword arguments. Returns: PackageSpec: the PackageSpec corresponding to the package, or None. \"\"\" if not exists ( package ): return None name , path = None , None enforce_init = kwargs . pop ( \"enforce_init\" , True ) if isdir ( package ): if isfile ( join ( package , \"__init__.py\" )) or not enforce_init : name , path = basename ( package ), package elif isfile ( package ) and package . endswith ( \".py\" ): name , path = splitext ( basename ( package ))[ 0 ], package if name and path : return PackageSpec ( name , path ) return None","title":"find()"},{"location":"reference/finder/#dependenpy.finder.PackageFinder","text":"Abstract package finder class.","title":"PackageFinder"},{"location":"reference/finder/#dependenpy.finder.PackageFinder.find","text":"Find method. Parameters: Name Type Description Default package str package to find. required **kwargs additional keyword arguments. {} Returns: Type Description PackageSpec the PackageSpec corresponding to the package, or None. Source code in dependenpy/finder.py 67 68 69 70 71 72 73 74 75 76 77 78 def find ( self , package , ** kwargs ): \"\"\" Find method. Args: package (str): package to find. **kwargs (): additional keyword arguments. Returns: PackageSpec: the PackageSpec corresponding to the package, or None. \"\"\" raise NotImplementedError","title":"find()"},{"location":"reference/finder/#dependenpy.finder.PackageSpec","text":"Holder for a package specification (given as argument to DSM).","title":"PackageSpec"},{"location":"reference/finder/#dependenpy.finder.PackageSpec.ismodule","text":"Property to tell if the package is in fact a module (a file).","title":"ismodule"},{"location":"reference/finder/#dependenpy.finder.PackageSpec.__init__","text":"Initialization method. Parameters: Name Type Description Default name str name of the package. required path str path to the package. required limit_to list of str limitations. None Source code in dependenpy/finder.py 12 13 14 15 16 17 18 19 20 21 22 23 def __init__ ( self , name , path , limit_to = None ): \"\"\" Initialization method. Args: name (str): name of the package. path (str): path to the package. limit_to (list of str): limitations. \"\"\" self . name = name self . path = path self . limit_to = limit_to or []","title":"__init__()"},{"location":"reference/finder/#dependenpy.finder.PackageSpec.add","text":"Add limitations of given spec to self's. Parameters: Name Type Description Default spec PackageSpec another spec. required Source code in dependenpy/finder.py 33 34 35 36 37 38 39 40 41 42 def add ( self , spec ): \"\"\" Add limitations of given spec to self's. Args: spec (PackageSpec): another spec. \"\"\" for limit in spec . limit_to : if limit not in self . limit_to : self . limit_to . append ( limit )","title":"add()"},{"location":"reference/finder/#dependenpy.finder.PackageSpec.combine","text":"Combine package specifications' limitations. Parameters: Name Type Description Default specs list of PackageSpec the package specifications. required Returns: Type Description list of PackageSpec the new, merged list of PackageSpec. Source code in dependenpy/finder.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @staticmethod def combine ( specs ): \"\"\" Combine package specifications' limitations. Args: specs (list of PackageSpec): the package specifications. Returns: list of PackageSpec: the new, merged list of PackageSpec. \"\"\" new_specs = {} for spec in specs : if new_specs . get ( spec , None ) is None : new_specs [ spec ] = spec else : new_specs [ spec ] . add ( spec ) return list ( new_specs . values ())","title":"combine()"},{"location":"reference/helpers/","text":"\u00a4 dependenpy printer module. PrintMixin \u00a4 Print mixin class. print ( self , format = 'text' , output =< _io . StringIO object at 0x7f1de655f318 > , ** kwargs ) \u00a4 Print the object in a file or on standard output by default. Parameters: Name Type Description Default format str output format (csv, json or text). 'text' output file descriptor to an opened file (default to standard output). <_io.StringIO object at 0x7f1de655f318> **kwargs additional arguments. {} Source code in dependenpy/helpers.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def print ( self , format = TEXT , output = sys . stdout , ** kwargs ): \"\"\" Print the object in a file or on standard output by default. Args: format (str): output format (csv, json or text). output (file): descriptor to an opened file (default to standard output). **kwargs (): additional arguments. \"\"\" if format is None : format = TEXT if format != TEXT : kwargs . pop ( \"zero\" , \"\" ) if format == TEXT : print ( self . _to_text ( ** kwargs ), file = output ) elif format == CSV : print ( self . _to_csv ( ** kwargs ), file = output ) elif format == JSON : print ( self . _to_json ( ** kwargs ), file = output ) guess_depth ( packages ) \u00a4 Guess the optimal depth to use for the given list of arguments. Parameters: Name Type Description Default packages list of str list of packages. required Returns: Type Description int guessed depth to use. Source code in dependenpy/helpers.py 49 50 51 52 53 54 55 56 57 58 59 60 61 def guess_depth ( packages ): \"\"\" Guess the optimal depth to use for the given list of arguments. Args: packages (list of str): list of packages. Returns: int: guessed depth to use. \"\"\" if len ( packages ) == 1 : return packages [ 0 ] . count ( \".\" ) + 2 return min ( p . count ( \".\" ) for p in packages ) + 1","title":"helpers.py"},{"location":"reference/helpers/#dependenpy.helpers","text":"dependenpy printer module.","title":"dependenpy.helpers"},{"location":"reference/helpers/#dependenpy.helpers.PrintMixin","text":"Print mixin class.","title":"PrintMixin"},{"location":"reference/helpers/#dependenpy.helpers.PrintMixin.print","text":"Print the object in a file or on standard output by default. Parameters: Name Type Description Default format str output format (csv, json or text). 'text' output file descriptor to an opened file (default to standard output). <_io.StringIO object at 0x7f1de655f318> **kwargs additional arguments. {} Source code in dependenpy/helpers.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def print ( self , format = TEXT , output = sys . stdout , ** kwargs ): \"\"\" Print the object in a file or on standard output by default. Args: format (str): output format (csv, json or text). output (file): descriptor to an opened file (default to standard output). **kwargs (): additional arguments. \"\"\" if format is None : format = TEXT if format != TEXT : kwargs . pop ( \"zero\" , \"\" ) if format == TEXT : print ( self . _to_text ( ** kwargs ), file = output ) elif format == CSV : print ( self . _to_csv ( ** kwargs ), file = output ) elif format == JSON : print ( self . _to_json ( ** kwargs ), file = output )","title":"print()"},{"location":"reference/helpers/#dependenpy.helpers.guess_depth","text":"Guess the optimal depth to use for the given list of arguments. Parameters: Name Type Description Default packages list of str list of packages. required Returns: Type Description int guessed depth to use. Source code in dependenpy/helpers.py 49 50 51 52 53 54 55 56 57 58 59 60 61 def guess_depth ( packages ): \"\"\" Guess the optimal depth to use for the given list of arguments. Args: packages (list of str): list of packages. Returns: int: guessed depth to use. \"\"\" if len ( packages ) == 1 : return packages [ 0 ] . count ( \".\" ) + 2 return min ( p . count ( \".\" ) for p in packages ) + 1","title":"guess_depth()"},{"location":"reference/node/","text":"\u00a4 dependenpy node module. LeafNode \u00a4 Shared code between Package and Module. depth property readonly \u00a4 Property to tell the depth of the node in the tree. Returns: Type Description int the node's depth in the tree. root property readonly \u00a4 Property to return the root of this node. Returns: Type Description Package this node's root package. __init__ ( self ) special \u00a4 Initialization method. Source code in dependenpy/node.py 346 347 348 def __init__ ( self ): \"\"\"Initialization method.\"\"\" self . _depth_cache = None __str__ ( self ) special \u00a4 String method. Source code in dependenpy/node.py 350 351 352 def __str__ ( self ): \"\"\"String method.\"\"\" return self . absolute_name () absolute_name ( self , depth = 0 ) \u00a4 Return the absolute name of the node. Concatenate names from root to self within depth. Parameters: Name Type Description Default depth int maximum depth to go to. 0 Returns: Type Description str absolute name of the node (until given depth is reached). Source code in dependenpy/node.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 def absolute_name ( self , depth = 0 ): \"\"\" Return the absolute name of the node. Concatenate names from root to self within depth. Args: depth (int): maximum depth to go to. Returns: str: absolute name of the node (until given depth is reached). \"\"\" node , node_depth = self , self . depth if depth < 1 : depth = node_depth while node_depth > depth and node . package is not None : node = node . package node_depth -= 1 names = [] while node is not None : names . append ( node . name ) node = node . package return \".\" . join ( reversed ( names )) NodeMixin \u00a4 Shared code between DSM, Package and Module. isdsm property readonly \u00a4 Property to check if object is instance of DSM. ismodule property readonly \u00a4 Property to check if object is instance of Module. ispackage property readonly \u00a4 Property to check if object is instance of Package. RootNode \u00a4 Shared code between DSM and Package. empty property readonly \u00a4 Whether the node has neither modules nor packages. Returns: Type Description bool True if empty, False otherwise. submodules property readonly \u00a4 Property to return all sub-modules of the node, recursively. Returns: Type Description list of Module the sub-modules. __bool__ ( self ) special \u00a4 Node as Boolean. Returns: Type Description bool result of node.empty. Source code in dependenpy/node.py 91 92 93 94 95 96 97 98 99 def __bool__ ( self ): \"\"\" Node as Boolean. Returns: bool: result of node.empty. \"\"\" return bool ( self . modules or self . packages ) __contains__ ( self , item ) special \u00a4 Get result of _contains, cache it and return it. Parameters: Name Type Description Default item Package/Module a package or module. required Returns: Type Description bool True if self contains item, False otherwise. Source code in dependenpy/node.py 52 53 54 55 56 57 58 59 60 61 62 63 64 def __contains__ ( self , item ): \"\"\" Get result of _contains, cache it and return it. Args: item (Package/Module): a package or module. Returns: bool: True if self contains item, False otherwise. \"\"\" if item not in self . _contains_cache : self . _contains_cache [ item ] = self . _contains ( item ) return self . _contains_cache [ item ] __getitem__ ( self , item ) special \u00a4 Return the corresponding Package or Module object. Parameters: Name Type Description Default item str name of the package/module, dot-separated. required Returns: Type Description Package/Module corresponding object. Source code in dependenpy/node.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def __getitem__ ( self , item ): \"\"\" Return the corresponding Package or Module object. Args: item (str): name of the package/module, dot-separated. Returns: Package/Module: corresponding object. \"\"\" depth = item . count ( \".\" ) + 1 parts = item . split ( \".\" , 1 ) for m in self . modules : if parts [ 0 ] == m . name : if depth == 1 : return m for p in self . packages : if parts [ 0 ] == p . name : if depth == 1 : return p item = p . get ( parts [ 1 ]) if item : return item raise KeyError ( item ) __init__ ( self , build_tree = True ) special \u00a4 Initialization method. Parameters: Name Type Description Default build_tree bool whether to immediately build the tree or not. True Source code in dependenpy/node.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , build_tree = True ): \"\"\" Initialization method. Args: build_tree (bool): whether to immediately build the tree or not. \"\"\" self . _target_cache = {} self . _item_cache = {} self . _contains_cache = {} self . _matrix_cache = {} self . _graph_cache = {} self . _treemap_cache = None self . modules = [] self . packages = [] if build_tree : self . build_tree () as_dict ( self ) \u00a4 Return the dependencies as a dictionary. Returns: Type Description dict dictionary of dependencies. Source code in dependenpy/node.py 287 288 289 290 291 292 293 294 295 296 297 298 def as_dict ( self ): \"\"\" Return the dependencies as a dictionary. Returns: dict: dictionary of dependencies. \"\"\" return { \"name\" : str ( self ), \"modules\" : [ m . as_dict () for m in self . modules ], \"packages\" : [ p . as_dict () for p in self . packages ], } as_graph ( self , depth = 0 ) \u00a4 Create a graph with self as node, cache it, return it. Parameters: Name Type Description Default depth int depth of the graph. 0 Returns: Type Description Graph an instance of Graph. Source code in dependenpy/node.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def as_graph ( self , depth = 0 ): \"\"\" Create a graph with self as node, cache it, return it. Args: depth (int): depth of the graph. Returns: Graph: an instance of Graph. \"\"\" if depth in self . _graph_cache : return self . _graph_cache [ depth ] self . _graph_cache [ depth ] = graph = Graph ( self , depth = depth ) return graph as_matrix ( self , depth = 0 ) \u00a4 Create a matrix with self as node, cache it, return it. Parameters: Name Type Description Default depth int depth of the matrix. 0 Returns: Type Description Matrix an instance of Matrix. Source code in dependenpy/node.py 315 316 317 318 319 320 321 322 323 324 325 326 327 328 def as_matrix ( self , depth = 0 ): \"\"\" Create a matrix with self as node, cache it, return it. Args: depth (int): depth of the matrix. Returns: Matrix: an instance of Matrix. \"\"\" if depth in self . _matrix_cache : return self . _matrix_cache [ depth ] self . _matrix_cache [ depth ] = matrix = Matrix ( self , depth = depth ) return matrix as_treemap ( self ) \u00a4 Return the dependencies as a TreeMap. Returns: Type Description TreeMap instance of TreeMap. Source code in dependenpy/node.py 330 331 332 333 334 335 336 337 338 339 340 def as_treemap ( self ): \"\"\" Return the dependencies as a TreeMap. Returns: TreeMap: instance of TreeMap. \"\"\" if self . _treemap_cache : return self . _treemap_cache self . _treemap_cache = treemap = TreeMap ( self ) return treemap build_dependencies ( self ) \u00a4 Recursively build the dependencies for sub-modules and sub-packages. Iterate on node's modules then packages and call their build_dependencies methods. Source code in dependenpy/node.py 215 216 217 218 219 220 221 222 223 224 225 def build_dependencies ( self ): \"\"\" Recursively build the dependencies for sub-modules and sub-packages. Iterate on node's modules then packages and call their build_dependencies methods. \"\"\" for m in self . modules : m . build_dependencies () for p in self . packages : p . build_dependencies () build_tree ( self ) \u00a4 To be overridden. Source code in dependenpy/node.py 125 126 127 def build_tree ( self ): \"\"\"To be overridden.\"\"\" raise NotImplementedError get ( self , item ) \u00a4 Get item through __getitem__ and cache the result. Parameters: Name Type Description Default item str name of package or module. required Returns: Type Description Package/Module the corresponding object. Source code in dependenpy/node.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def get ( self , item ): \"\"\" Get item through ``__getitem__`` and cache the result. Args: item (str): name of package or module. Returns: Package/Module: the corresponding object. \"\"\" if item not in self . _item_cache : try : item = self . __getitem__ ( item ) except KeyError : item = None self . _item_cache [ item ] = item return self . _item_cache [ item ] get_target ( self , target ) \u00a4 Get the result of _get_target, cache it and return it. Parameters: Name Type Description Default target str target to find. required Returns: Type Description Package/Module package containing target or corresponding module. Source code in dependenpy/node.py 167 168 169 170 171 172 173 174 175 176 177 178 179 def get_target ( self , target ): \"\"\" Get the result of _get_target, cache it and return it. Args: target (str): target to find. Returns: Package/Module: package containing target or corresponding module. \"\"\" if target not in self . _target_cache : self . _target_cache [ target ] = self . _get_target ( target ) return self . _target_cache [ target ] print_graph ( self , format = None , output =< _io . StringIO object at 0x7f1de655f318 > , depth = 0 , ** kwargs ) \u00a4 Print the graph for self's nodes. Parameters: Name Type Description Default format str output format (csv, json or text). None output file file descriptor on which to write. <_io.StringIO object at 0x7f1de655f318> depth int depth of the graph. 0 Source code in dependenpy/node.py 227 228 229 230 231 232 233 234 235 236 237 def print_graph ( self , format = None , output = sys . stdout , depth = 0 , ** kwargs ): \"\"\" Print the graph for self's nodes. Args: format (str): output format (csv, json or text). output (file): file descriptor on which to write. depth (int): depth of the graph. \"\"\" graph = self . as_graph ( depth = depth ) graph . print ( format = format , output = output , ** kwargs ) print_matrix ( self , format = None , output =< _io . StringIO object at 0x7f1de655f318 > , depth = 0 , ** kwargs ) \u00a4 Print the matrix for self's nodes. Parameters: Name Type Description Default format str output format (csv, json or text). None output file file descriptor on which to write. <_io.StringIO object at 0x7f1de655f318> depth int depth of the matrix. 0 Source code in dependenpy/node.py 239 240 241 242 243 244 245 246 247 248 249 def print_matrix ( self , format = None , output = sys . stdout , depth = 0 , ** kwargs ): \"\"\" Print the matrix for self's nodes. Args: format (str): output format (csv, json or text). output (file): file descriptor on which to write. depth (int): depth of the matrix. \"\"\" matrix = self . as_matrix ( depth = depth ) matrix . print ( format = format , output = output , ** kwargs ) print_treemap ( self , format = None , output =< _io . StringIO object at 0x7f1de655f318 > , ** kwargs ) \u00a4 Print the matrix for self's nodes. Parameters: Name Type Description Default format str output format (csv, json or text). None output file file descriptor on which to write. <_io.StringIO object at 0x7f1de655f318> Source code in dependenpy/node.py 251 252 253 254 255 256 257 258 259 260 def print_treemap ( self , format = None , output = sys . stdout , ** kwargs ): \"\"\" Print the matrix for self's nodes. Args: format (str): output format (csv, json or text). output (file): file descriptor on which to write. \"\"\" treemap = self . as_treemap () treemap . print ( format = format , output = output , ** kwargs )","title":"node.py"},{"location":"reference/node/#dependenpy.node","text":"dependenpy node module.","title":"dependenpy.node"},{"location":"reference/node/#dependenpy.node.LeafNode","text":"Shared code between Package and Module.","title":"LeafNode"},{"location":"reference/node/#dependenpy.node.LeafNode.depth","text":"Property to tell the depth of the node in the tree. Returns: Type Description int the node's depth in the tree.","title":"depth"},{"location":"reference/node/#dependenpy.node.LeafNode.root","text":"Property to return the root of this node. Returns: Type Description Package this node's root package.","title":"root"},{"location":"reference/node/#dependenpy.node.LeafNode.__init__","text":"Initialization method. Source code in dependenpy/node.py 346 347 348 def __init__ ( self ): \"\"\"Initialization method.\"\"\" self . _depth_cache = None","title":"__init__()"},{"location":"reference/node/#dependenpy.node.LeafNode.__str__","text":"String method. Source code in dependenpy/node.py 350 351 352 def __str__ ( self ): \"\"\"String method.\"\"\" return self . absolute_name ()","title":"__str__()"},{"location":"reference/node/#dependenpy.node.LeafNode.absolute_name","text":"Return the absolute name of the node. Concatenate names from root to self within depth. Parameters: Name Type Description Default depth int maximum depth to go to. 0 Returns: Type Description str absolute name of the node (until given depth is reached). Source code in dependenpy/node.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 def absolute_name ( self , depth = 0 ): \"\"\" Return the absolute name of the node. Concatenate names from root to self within depth. Args: depth (int): maximum depth to go to. Returns: str: absolute name of the node (until given depth is reached). \"\"\" node , node_depth = self , self . depth if depth < 1 : depth = node_depth while node_depth > depth and node . package is not None : node = node . package node_depth -= 1 names = [] while node is not None : names . append ( node . name ) node = node . package return \".\" . join ( reversed ( names ))","title":"absolute_name()"},{"location":"reference/node/#dependenpy.node.NodeMixin","text":"Shared code between DSM, Package and Module.","title":"NodeMixin"},{"location":"reference/node/#dependenpy.node.NodeMixin.isdsm","text":"Property to check if object is instance of DSM.","title":"isdsm"},{"location":"reference/node/#dependenpy.node.NodeMixin.ismodule","text":"Property to check if object is instance of Module.","title":"ismodule"},{"location":"reference/node/#dependenpy.node.NodeMixin.ispackage","text":"Property to check if object is instance of Package.","title":"ispackage"},{"location":"reference/node/#dependenpy.node.RootNode","text":"Shared code between DSM and Package.","title":"RootNode"},{"location":"reference/node/#dependenpy.node.RootNode.empty","text":"Whether the node has neither modules nor packages. Returns: Type Description bool True if empty, False otherwise.","title":"empty"},{"location":"reference/node/#dependenpy.node.RootNode.submodules","text":"Property to return all sub-modules of the node, recursively. Returns: Type Description list of Module the sub-modules.","title":"submodules"},{"location":"reference/node/#dependenpy.node.RootNode.__bool__","text":"Node as Boolean. Returns: Type Description bool result of node.empty. Source code in dependenpy/node.py 91 92 93 94 95 96 97 98 99 def __bool__ ( self ): \"\"\" Node as Boolean. Returns: bool: result of node.empty. \"\"\" return bool ( self . modules or self . packages )","title":"__bool__()"},{"location":"reference/node/#dependenpy.node.RootNode.__contains__","text":"Get result of _contains, cache it and return it. Parameters: Name Type Description Default item Package/Module a package or module. required Returns: Type Description bool True if self contains item, False otherwise. Source code in dependenpy/node.py 52 53 54 55 56 57 58 59 60 61 62 63 64 def __contains__ ( self , item ): \"\"\" Get result of _contains, cache it and return it. Args: item (Package/Module): a package or module. Returns: bool: True if self contains item, False otherwise. \"\"\" if item not in self . _contains_cache : self . _contains_cache [ item ] = self . _contains ( item ) return self . _contains_cache [ item ]","title":"__contains__()"},{"location":"reference/node/#dependenpy.node.RootNode.__getitem__","text":"Return the corresponding Package or Module object. Parameters: Name Type Description Default item str name of the package/module, dot-separated. required Returns: Type Description Package/Module corresponding object. Source code in dependenpy/node.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def __getitem__ ( self , item ): \"\"\" Return the corresponding Package or Module object. Args: item (str): name of the package/module, dot-separated. Returns: Package/Module: corresponding object. \"\"\" depth = item . count ( \".\" ) + 1 parts = item . split ( \".\" , 1 ) for m in self . modules : if parts [ 0 ] == m . name : if depth == 1 : return m for p in self . packages : if parts [ 0 ] == p . name : if depth == 1 : return p item = p . get ( parts [ 1 ]) if item : return item raise KeyError ( item )","title":"__getitem__()"},{"location":"reference/node/#dependenpy.node.RootNode.__init__","text":"Initialization method. Parameters: Name Type Description Default build_tree bool whether to immediately build the tree or not. True Source code in dependenpy/node.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , build_tree = True ): \"\"\" Initialization method. Args: build_tree (bool): whether to immediately build the tree or not. \"\"\" self . _target_cache = {} self . _item_cache = {} self . _contains_cache = {} self . _matrix_cache = {} self . _graph_cache = {} self . _treemap_cache = None self . modules = [] self . packages = [] if build_tree : self . build_tree ()","title":"__init__()"},{"location":"reference/node/#dependenpy.node.RootNode.as_dict","text":"Return the dependencies as a dictionary. Returns: Type Description dict dictionary of dependencies. Source code in dependenpy/node.py 287 288 289 290 291 292 293 294 295 296 297 298 def as_dict ( self ): \"\"\" Return the dependencies as a dictionary. Returns: dict: dictionary of dependencies. \"\"\" return { \"name\" : str ( self ), \"modules\" : [ m . as_dict () for m in self . modules ], \"packages\" : [ p . as_dict () for p in self . packages ], }","title":"as_dict()"},{"location":"reference/node/#dependenpy.node.RootNode.as_graph","text":"Create a graph with self as node, cache it, return it. Parameters: Name Type Description Default depth int depth of the graph. 0 Returns: Type Description Graph an instance of Graph. Source code in dependenpy/node.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def as_graph ( self , depth = 0 ): \"\"\" Create a graph with self as node, cache it, return it. Args: depth (int): depth of the graph. Returns: Graph: an instance of Graph. \"\"\" if depth in self . _graph_cache : return self . _graph_cache [ depth ] self . _graph_cache [ depth ] = graph = Graph ( self , depth = depth ) return graph","title":"as_graph()"},{"location":"reference/node/#dependenpy.node.RootNode.as_matrix","text":"Create a matrix with self as node, cache it, return it. Parameters: Name Type Description Default depth int depth of the matrix. 0 Returns: Type Description Matrix an instance of Matrix. Source code in dependenpy/node.py 315 316 317 318 319 320 321 322 323 324 325 326 327 328 def as_matrix ( self , depth = 0 ): \"\"\" Create a matrix with self as node, cache it, return it. Args: depth (int): depth of the matrix. Returns: Matrix: an instance of Matrix. \"\"\" if depth in self . _matrix_cache : return self . _matrix_cache [ depth ] self . _matrix_cache [ depth ] = matrix = Matrix ( self , depth = depth ) return matrix","title":"as_matrix()"},{"location":"reference/node/#dependenpy.node.RootNode.as_treemap","text":"Return the dependencies as a TreeMap. Returns: Type Description TreeMap instance of TreeMap. Source code in dependenpy/node.py 330 331 332 333 334 335 336 337 338 339 340 def as_treemap ( self ): \"\"\" Return the dependencies as a TreeMap. Returns: TreeMap: instance of TreeMap. \"\"\" if self . _treemap_cache : return self . _treemap_cache self . _treemap_cache = treemap = TreeMap ( self ) return treemap","title":"as_treemap()"},{"location":"reference/node/#dependenpy.node.RootNode.build_dependencies","text":"Recursively build the dependencies for sub-modules and sub-packages. Iterate on node's modules then packages and call their build_dependencies methods. Source code in dependenpy/node.py 215 216 217 218 219 220 221 222 223 224 225 def build_dependencies ( self ): \"\"\" Recursively build the dependencies for sub-modules and sub-packages. Iterate on node's modules then packages and call their build_dependencies methods. \"\"\" for m in self . modules : m . build_dependencies () for p in self . packages : p . build_dependencies ()","title":"build_dependencies()"},{"location":"reference/node/#dependenpy.node.RootNode.build_tree","text":"To be overridden. Source code in dependenpy/node.py 125 126 127 def build_tree ( self ): \"\"\"To be overridden.\"\"\" raise NotImplementedError","title":"build_tree()"},{"location":"reference/node/#dependenpy.node.RootNode.get","text":"Get item through __getitem__ and cache the result. Parameters: Name Type Description Default item str name of package or module. required Returns: Type Description Package/Module the corresponding object. Source code in dependenpy/node.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def get ( self , item ): \"\"\" Get item through ``__getitem__`` and cache the result. Args: item (str): name of package or module. Returns: Package/Module: the corresponding object. \"\"\" if item not in self . _item_cache : try : item = self . __getitem__ ( item ) except KeyError : item = None self . _item_cache [ item ] = item return self . _item_cache [ item ]","title":"get()"},{"location":"reference/node/#dependenpy.node.RootNode.get_target","text":"Get the result of _get_target, cache it and return it. Parameters: Name Type Description Default target str target to find. required Returns: Type Description Package/Module package containing target or corresponding module. Source code in dependenpy/node.py 167 168 169 170 171 172 173 174 175 176 177 178 179 def get_target ( self , target ): \"\"\" Get the result of _get_target, cache it and return it. Args: target (str): target to find. Returns: Package/Module: package containing target or corresponding module. \"\"\" if target not in self . _target_cache : self . _target_cache [ target ] = self . _get_target ( target ) return self . _target_cache [ target ]","title":"get_target()"},{"location":"reference/node/#dependenpy.node.RootNode.print_graph","text":"Print the graph for self's nodes. Parameters: Name Type Description Default format str output format (csv, json or text). None output file file descriptor on which to write. <_io.StringIO object at 0x7f1de655f318> depth int depth of the graph. 0 Source code in dependenpy/node.py 227 228 229 230 231 232 233 234 235 236 237 def print_graph ( self , format = None , output = sys . stdout , depth = 0 , ** kwargs ): \"\"\" Print the graph for self's nodes. Args: format (str): output format (csv, json or text). output (file): file descriptor on which to write. depth (int): depth of the graph. \"\"\" graph = self . as_graph ( depth = depth ) graph . print ( format = format , output = output , ** kwargs )","title":"print_graph()"},{"location":"reference/node/#dependenpy.node.RootNode.print_matrix","text":"Print the matrix for self's nodes. Parameters: Name Type Description Default format str output format (csv, json or text). None output file file descriptor on which to write. <_io.StringIO object at 0x7f1de655f318> depth int depth of the matrix. 0 Source code in dependenpy/node.py 239 240 241 242 243 244 245 246 247 248 249 def print_matrix ( self , format = None , output = sys . stdout , depth = 0 , ** kwargs ): \"\"\" Print the matrix for self's nodes. Args: format (str): output format (csv, json or text). output (file): file descriptor on which to write. depth (int): depth of the matrix. \"\"\" matrix = self . as_matrix ( depth = depth ) matrix . print ( format = format , output = output , ** kwargs )","title":"print_matrix()"},{"location":"reference/node/#dependenpy.node.RootNode.print_treemap","text":"Print the matrix for self's nodes. Parameters: Name Type Description Default format str output format (csv, json or text). None output file file descriptor on which to write. <_io.StringIO object at 0x7f1de655f318> Source code in dependenpy/node.py 251 252 253 254 255 256 257 258 259 260 def print_treemap ( self , format = None , output = sys . stdout , ** kwargs ): \"\"\" Print the matrix for self's nodes. Args: format (str): output format (csv, json or text). output (file): file descriptor on which to write. \"\"\" treemap = self . as_treemap () treemap . print ( format = format , output = output , ** kwargs )","title":"print_treemap()"},{"location":"reference/plugins/","text":"\u00a4 dependenpy plugins module. InternalDependencies \u00a4 Empty dependenpy provider.","title":"plugins.py"},{"location":"reference/plugins/#dependenpy.plugins","text":"dependenpy plugins module.","title":"dependenpy.plugins"},{"location":"reference/plugins/#dependenpy.plugins.InternalDependencies","text":"Empty dependenpy provider.","title":"InternalDependencies"},{"location":"reference/structures/","text":"\u00a4 dependenpy structures module. Edge \u00a4 Edge class. Used in Graph class. __init__ ( self , vertex_out , vertex_in , weight = 1 ) special \u00a4 Initialization method. Parameters: Name Type Description Default vertex_out Vertex source vertex (edge going out). required vertex_in Vertex target vertex (edge going in). required weight int weight of the edge. 1 Source code in dependenpy/structures.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 def __init__ ( self , vertex_out , vertex_in , weight = 1 ): \"\"\" Initialization method. Args: vertex_out (Vertex): source vertex (edge going out). vertex_in (Vertex): target vertex (edge going in). weight (int): weight of the edge. \"\"\" self . vertex_out = None self . vertex_in = None self . weight = weight self . go_from ( vertex_out ) self . go_in ( vertex_in ) go_from ( self , vertex ) \u00a4 Tell the edge to go out from this vertex. Parameters: Name Type Description Default vertex Vertex vertex to go from. required Source code in dependenpy/structures.py 254 255 256 257 258 259 260 261 262 263 264 def go_from ( self , vertex ): \"\"\" Tell the edge to go out from this vertex. Args: vertex (Vertex): vertex to go from. \"\"\" if self . vertex_out : self . vertex_out . edges_out . remove ( self ) self . vertex_out = vertex vertex . edges_out . add ( self ) go_in ( self , vertex ) \u00a4 Tell the edge to go into this vertex. Parameters: Name Type Description Default vertex Vertex vertex to go into. required Source code in dependenpy/structures.py 266 267 268 269 270 271 272 273 274 275 276 def go_in ( self , vertex ): \"\"\" Tell the edge to go into this vertex. Args: vertex (Vertex): vertex to go into. \"\"\" if self . vertex_in : self . vertex_in . edges_in . remove ( self ) self . vertex_in = vertex vertex . edges_in . add ( self ) Graph \u00a4 Graph class. A class to build a graph given a list of nodes. After instantiation, it has two attributes: vertices, the set of nodes, and edges, the set of edges. __init__ ( self , * nodes , * , depth = 0 ) special \u00a4 Initialization method. An intermediary matrix is built to ease the creation of the graph. Parameters: Name Type Description Default *nodes list of DSM/Package/Module the nodes on which to build the graph. () depth int the depth of the intermediary matrix. See the documentation for Matrix class. 0 Source code in dependenpy/structures.py 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def __init__ ( self , * nodes , depth = 0 ): \"\"\" Initialization method. An intermediary matrix is built to ease the creation of the graph. Args: *nodes (list of DSM/Package/Module): the nodes on which to build the graph. depth (int): the depth of the intermediary matrix. See the documentation for Matrix class. \"\"\" self . edges = set () vertices = [] matrix = Matrix ( * nodes , depth = depth ) for key in matrix . keys : vertices . append ( Vertex ( key )) for l , line in enumerate ( matrix . data ): for c , cell in enumerate ( line ): if cell > 0 : self . edges . add ( Edge ( vertices [ l ], vertices [ c ], weight = cell )) self . vertices = set ( vertices ) Matrix \u00a4 Matrix class. A class to build a matrix given a list of nodes. After instantiation, it has two attributes: data, a 2-dimensions array, and keys, the names of the entities in the corresponding order. total property readonly \u00a4 Return the total number of dependencies within this matrix. __init__ ( self , * nodes , * , depth = 0 ) special \u00a4 Initialization method. Parameters: Name Type Description Default *nodes list of DSM/Package/Module the nodes on which to build the matrix. () depth int the depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4. 0 Source code in dependenpy/structures.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def __init__ ( self , * nodes , depth = 0 ): \"\"\" Initialization method. Args: *nodes (list of DSM/Package/Module): the nodes on which to build the matrix. depth (int): the depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4. \"\"\" modules = [] for node in nodes : if node . ismodule : modules . append ( node ) elif node . ispackage or node . isdsm : modules . extend ( node . submodules ) if depth < 1 : keys = modules else : keys = [] for m in modules : if m . depth <= depth : keys . append ( m ) continue package = m . package while package . depth > depth and package . package and package not in nodes : package = package . package if package not in keys : keys . append ( package ) size = len ( keys ) data = [[ 0 for _ in range ( size )] for __ in range ( size )] keys = sorted ( keys , key = lambda k : k . absolute_name ()) if depth < 1 : for i , k in enumerate ( keys ): k . index = i for i , k in enumerate ( keys ): for d in k . dependencies : if d . external : continue if d . target . ismodule and d . target in keys : data [ i ][ d . target . index ] += 1 elif d . target . ispackage : m = d . target . get ( \"__init__\" ) if m is not None and m in keys : data [ i ][ m . index ] += 1 else : for i , k in enumerate ( keys ): for j , l in enumerate ( keys ): data [ i ][ j ] = k . cardinal ( to = l ) self . size = size self . keys = [ k . absolute_name () for k in keys ] self . data = data cast ( keys , data ) staticmethod \u00a4 Cast a set of keys and an array to a Matrix object. Source code in dependenpy/structures.py 81 82 83 84 85 86 87 @staticmethod def cast ( keys , data ): \"\"\"Cast a set of keys and an array to a Matrix object.\"\"\" matrix = Matrix () matrix . keys = keys matrix . data = data return matrix TreeMap \u00a4 TreeMap class. __init__ ( self , * nodes , * , value =- 1 , data = None , keys = None ) special \u00a4 Initialization method. Parameters: Name Type Description Default *nodes list of Node the nodes from which to build the treemap. () Source code in dependenpy/structures.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def __init__ ( self , * nodes , value =- 1 , data = None , keys = None ): \"\"\" Initialization method. Arguments: *nodes (list of Node): the nodes from which to build the treemap. \"\"\" # if nodes: # matrix_lower_level = Matrix(*nodes, depth=2) # matrix_current_level = Matrix(*nodes, depth=1) # if value == -1: # value = sum(c for row in matrix_current_level.data for c in row) # splits = [0] # key_comp = matrix_lower_level.keys[0].split('.')[0] # i = 1 # for key in matrix_lower_level.keys[1:]: # key = key.split('.')[0] # if key != key_comp: # splits.append(i) # key_comp = key # i += 1 # splits.append(i) # # self.data = [] # for i in range(len(splits) - 1): # self.data.append([]) # rows = matrix_lower_level.data[splits[i]:splits[i+1]] # for j in range(len(splits) - 1): # self.data[i].append([row[splits[j]:splits[j+1]] for row in rows]) self . value = value Vertex \u00a4 Vertex class. Used in Graph class. __init__ ( self , name ) special \u00a4 Initialization method. Parameters: Name Type Description Default name str name of the vertex. required Source code in dependenpy/structures.py 186 187 188 189 190 191 192 193 194 195 def __init__ ( self , name ): \"\"\" Initialization method. Args: name (str): name of the vertex. \"\"\" self . name = name self . edges_in = set () self . edges_out = set () connect_from ( self , vertex , weight = 1 ) \u00a4 Connect another vertex to this one. Parameters: Name Type Description Default vertex Vertex vertex to connect from. required weight int weight of the edge. 1 Returns: Type Description Edge the newly created edge. Source code in dependenpy/structures.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 def connect_from ( self , vertex , weight = 1 ): \"\"\" Connect another vertex to this one. Args: vertex (Vertex): vertex to connect from. weight (int): weight of the edge. Returns: Edge: the newly created edge. \"\"\" for edge in self . edges_in : if vertex == edge . vertex_out : return edge return Edge ( vertex , self , weight ) connect_to ( self , vertex , weight = 1 ) \u00a4 Connect this vertex to another one. Parameters: Name Type Description Default vertex Vertex vertex to connect to. required weight int weight of the edge. 1 Returns: Type Description Edge the newly created edge. Source code in dependenpy/structures.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 def connect_to ( self , vertex , weight = 1 ): \"\"\" Connect this vertex to another one. Args: vertex (Vertex): vertex to connect to. weight (int): weight of the edge. Returns: Edge: the newly created edge. \"\"\" for edge in self . edges_out : if vertex == edge . vertex_in : return edge return Edge ( self , vertex , weight )","title":"structures.py"},{"location":"reference/structures/#dependenpy.structures","text":"dependenpy structures module.","title":"dependenpy.structures"},{"location":"reference/structures/#dependenpy.structures.Edge","text":"Edge class. Used in Graph class.","title":"Edge"},{"location":"reference/structures/#dependenpy.structures.Edge.__init__","text":"Initialization method. Parameters: Name Type Description Default vertex_out Vertex source vertex (edge going out). required vertex_in Vertex target vertex (edge going in). required weight int weight of the edge. 1 Source code in dependenpy/structures.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 def __init__ ( self , vertex_out , vertex_in , weight = 1 ): \"\"\" Initialization method. Args: vertex_out (Vertex): source vertex (edge going out). vertex_in (Vertex): target vertex (edge going in). weight (int): weight of the edge. \"\"\" self . vertex_out = None self . vertex_in = None self . weight = weight self . go_from ( vertex_out ) self . go_in ( vertex_in )","title":"__init__()"},{"location":"reference/structures/#dependenpy.structures.Edge.go_from","text":"Tell the edge to go out from this vertex. Parameters: Name Type Description Default vertex Vertex vertex to go from. required Source code in dependenpy/structures.py 254 255 256 257 258 259 260 261 262 263 264 def go_from ( self , vertex ): \"\"\" Tell the edge to go out from this vertex. Args: vertex (Vertex): vertex to go from. \"\"\" if self . vertex_out : self . vertex_out . edges_out . remove ( self ) self . vertex_out = vertex vertex . edges_out . add ( self )","title":"go_from()"},{"location":"reference/structures/#dependenpy.structures.Edge.go_in","text":"Tell the edge to go into this vertex. Parameters: Name Type Description Default vertex Vertex vertex to go into. required Source code in dependenpy/structures.py 266 267 268 269 270 271 272 273 274 275 276 def go_in ( self , vertex ): \"\"\" Tell the edge to go into this vertex. Args: vertex (Vertex): vertex to go into. \"\"\" if self . vertex_in : self . vertex_in . edges_in . remove ( self ) self . vertex_in = vertex vertex . edges_in . add ( self )","title":"go_in()"},{"location":"reference/structures/#dependenpy.structures.Graph","text":"Graph class. A class to build a graph given a list of nodes. After instantiation, it has two attributes: vertices, the set of nodes, and edges, the set of edges.","title":"Graph"},{"location":"reference/structures/#dependenpy.structures.Graph.__init__","text":"Initialization method. An intermediary matrix is built to ease the creation of the graph. Parameters: Name Type Description Default *nodes list of DSM/Package/Module the nodes on which to build the graph. () depth int the depth of the intermediary matrix. See the documentation for Matrix class. 0 Source code in dependenpy/structures.py 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def __init__ ( self , * nodes , depth = 0 ): \"\"\" Initialization method. An intermediary matrix is built to ease the creation of the graph. Args: *nodes (list of DSM/Package/Module): the nodes on which to build the graph. depth (int): the depth of the intermediary matrix. See the documentation for Matrix class. \"\"\" self . edges = set () vertices = [] matrix = Matrix ( * nodes , depth = depth ) for key in matrix . keys : vertices . append ( Vertex ( key )) for l , line in enumerate ( matrix . data ): for c , cell in enumerate ( line ): if cell > 0 : self . edges . add ( Edge ( vertices [ l ], vertices [ c ], weight = cell )) self . vertices = set ( vertices )","title":"__init__()"},{"location":"reference/structures/#dependenpy.structures.Matrix","text":"Matrix class. A class to build a matrix given a list of nodes. After instantiation, it has two attributes: data, a 2-dimensions array, and keys, the names of the entities in the corresponding order.","title":"Matrix"},{"location":"reference/structures/#dependenpy.structures.Matrix.total","text":"Return the total number of dependencies within this matrix.","title":"total"},{"location":"reference/structures/#dependenpy.structures.Matrix.__init__","text":"Initialization method. Parameters: Name Type Description Default *nodes list of DSM/Package/Module the nodes on which to build the matrix. () depth int the depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4. 0 Source code in dependenpy/structures.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def __init__ ( self , * nodes , depth = 0 ): \"\"\" Initialization method. Args: *nodes (list of DSM/Package/Module): the nodes on which to build the matrix. depth (int): the depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4. \"\"\" modules = [] for node in nodes : if node . ismodule : modules . append ( node ) elif node . ispackage or node . isdsm : modules . extend ( node . submodules ) if depth < 1 : keys = modules else : keys = [] for m in modules : if m . depth <= depth : keys . append ( m ) continue package = m . package while package . depth > depth and package . package and package not in nodes : package = package . package if package not in keys : keys . append ( package ) size = len ( keys ) data = [[ 0 for _ in range ( size )] for __ in range ( size )] keys = sorted ( keys , key = lambda k : k . absolute_name ()) if depth < 1 : for i , k in enumerate ( keys ): k . index = i for i , k in enumerate ( keys ): for d in k . dependencies : if d . external : continue if d . target . ismodule and d . target in keys : data [ i ][ d . target . index ] += 1 elif d . target . ispackage : m = d . target . get ( \"__init__\" ) if m is not None and m in keys : data [ i ][ m . index ] += 1 else : for i , k in enumerate ( keys ): for j , l in enumerate ( keys ): data [ i ][ j ] = k . cardinal ( to = l ) self . size = size self . keys = [ k . absolute_name () for k in keys ] self . data = data","title":"__init__()"},{"location":"reference/structures/#dependenpy.structures.Matrix.cast","text":"Cast a set of keys and an array to a Matrix object. Source code in dependenpy/structures.py 81 82 83 84 85 86 87 @staticmethod def cast ( keys , data ): \"\"\"Cast a set of keys and an array to a Matrix object.\"\"\" matrix = Matrix () matrix . keys = keys matrix . data = data return matrix","title":"cast()"},{"location":"reference/structures/#dependenpy.structures.TreeMap","text":"TreeMap class.","title":"TreeMap"},{"location":"reference/structures/#dependenpy.structures.TreeMap.__init__","text":"Initialization method. Parameters: Name Type Description Default *nodes list of Node the nodes from which to build the treemap. () Source code in dependenpy/structures.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def __init__ ( self , * nodes , value =- 1 , data = None , keys = None ): \"\"\" Initialization method. Arguments: *nodes (list of Node): the nodes from which to build the treemap. \"\"\" # if nodes: # matrix_lower_level = Matrix(*nodes, depth=2) # matrix_current_level = Matrix(*nodes, depth=1) # if value == -1: # value = sum(c for row in matrix_current_level.data for c in row) # splits = [0] # key_comp = matrix_lower_level.keys[0].split('.')[0] # i = 1 # for key in matrix_lower_level.keys[1:]: # key = key.split('.')[0] # if key != key_comp: # splits.append(i) # key_comp = key # i += 1 # splits.append(i) # # self.data = [] # for i in range(len(splits) - 1): # self.data.append([]) # rows = matrix_lower_level.data[splits[i]:splits[i+1]] # for j in range(len(splits) - 1): # self.data[i].append([row[splits[j]:splits[j+1]] for row in rows]) self . value = value","title":"__init__()"},{"location":"reference/structures/#dependenpy.structures.Vertex","text":"Vertex class. Used in Graph class.","title":"Vertex"},{"location":"reference/structures/#dependenpy.structures.Vertex.__init__","text":"Initialization method. Parameters: Name Type Description Default name str name of the vertex. required Source code in dependenpy/structures.py 186 187 188 189 190 191 192 193 194 195 def __init__ ( self , name ): \"\"\" Initialization method. Args: name (str): name of the vertex. \"\"\" self . name = name self . edges_in = set () self . edges_out = set ()","title":"__init__()"},{"location":"reference/structures/#dependenpy.structures.Vertex.connect_from","text":"Connect another vertex to this one. Parameters: Name Type Description Default vertex Vertex vertex to connect from. required weight int weight of the edge. 1 Returns: Type Description Edge the newly created edge. Source code in dependenpy/structures.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 def connect_from ( self , vertex , weight = 1 ): \"\"\" Connect another vertex to this one. Args: vertex (Vertex): vertex to connect from. weight (int): weight of the edge. Returns: Edge: the newly created edge. \"\"\" for edge in self . edges_in : if vertex == edge . vertex_out : return edge return Edge ( vertex , self , weight )","title":"connect_from()"},{"location":"reference/structures/#dependenpy.structures.Vertex.connect_to","text":"Connect this vertex to another one. Parameters: Name Type Description Default vertex Vertex vertex to connect to. required weight int weight of the edge. 1 Returns: Type Description Edge the newly created edge. Source code in dependenpy/structures.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 def connect_to ( self , vertex , weight = 1 ): \"\"\" Connect this vertex to another one. Args: vertex (Vertex): vertex to connect to. weight (int): weight of the edge. Returns: Edge: the newly created edge. \"\"\" for edge in self . edges_out : if vertex == edge . vertex_in : return edge return Edge ( self , vertex , weight )","title":"connect_to()"}]}